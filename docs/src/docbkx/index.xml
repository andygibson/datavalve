<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<book>
    <title>Spigot Reference Guide</title>
    <titleabbrev>Spigot Ref</titleabbrev>
    <bookinfo>
        <author>
            <personname>
                <firstname>Andy</firstname>
                <surname>Gibson</surname>
            </personname>
        </author>
        <orgname>FlutterCode</orgname>
        <authorinitials>AMG</authorinitials>
        <copyright>
            <year>2010</year>
            <holder>Andy Gibson</holder>
        </copyright>
    </bookinfo>
    <preface>
    <title>Preface</title>
    </preface>
    <chapter id="Introduction">
        <title>Introduction</title>
        <para>
            The purpose of this framework is to let developers use different
            sources of data in a consistent manner that leverages the
            similarities to create common interfaces to access them. It also
            aims to augment the functions of existing data access mechanisms,
            again leveraging the similarities between providers to create common
            extensions.
        </para>
        <sect1>
            <title>The Itch</title>
            <para>
                When starting a new data driven application developers
                typically need some mechanism to query data with the following
                capabilities:
        </para>
            <itemizedlist>
                <listitem>
                    <para>Pagination of large datasets</para>
                </listitem>
                <listitem>
                    <para>Dynamic Ordering (for clickable columns)</para>
                </listitem>
                <listitem>
                    <para>Lazy Loading of data for large datasets</para>
                </listitem>
                <listitem>
                    <para>Optional restrictions in the query for when parameter
                        values are missing</para>
                </listitem>
                <listitem>
                    <para>The ability to apply a common front end to the back
                        end data access mechanism so you can reuse both the
                        front and back end to implement forms in minutes.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                As a long time Seam user, Seam provides most of this with the
                <classname>EntityQuery</classname>
                that can be used to run queries using JPA but it isn't perfect.
                I extended the Seam
                <classname>EntityQuery</classname>
                and
                <ulink
                    url="http://www.andygibson.net/blog/index.php/2008/10/02/codeless-ajax-ordered-and-paginated-tables-in-seam/">blogged about it </ulink>
                and it still remains a popular article today when people are
                looking for info on JSF and pagination. However this solution
                only works in Seam projects but the same functionality is needed
                in Wicket, Spring, JSP and even Swing and console apps. Other
                frameworks such as Wicket provide a front end and back end
                interface for handling ordered paginated datasets, but the
                actual implementation is up to the user as this is beyond the
                scope of Wicket.
            </para>

            <para>The other source of inspiration is from Borland Delphi which
                worked on the idea that a common data access interface meant
                that data driven components could access data without
                considering where it came from. A standard data interface meant
                that third party Delphi component developers could create data
                access components that would work with any kind of data source,
                from Oracle, MySQL and MS Access to XML or file based datasets
                as long as there was a data provider implementation for it. When
                developing in Java, you typically have to code against a common
                but more specific back end such as a JDBC query and write new
                interfaces for different view technologies. If you write the
                front end code for say JPA or Hibernate and you need to access
                an alternative data source then typically you cannot re-use your
                existing code for the new data source.</para>
            <para>It seems that all these frameworks recognized the need for
                controlled data access but it was beyond the scope of the
                individual frameworks to provide a cross framework solution.
            </para>
            <figure>
                <title>Projects without using Spigot</title>
                <mediaobject>
                    <imageobject role="fo">
                        <imagedata align="center" fileref="../img/app_without_jds.png"
                            scalefit="1" />
                    </imageobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="../img/app_without_jds.png" />
                    </imageobject>
                </mediaobject>
            </figure>


        </sect1>

        <sect1>
            <title>The Solution</title>
            <para>So, I scratched my own itch and created this project which
                defines a common API for querying diverse data sources with
                pagination, ordering, restrictions and parameter management.
                This lets us write common view code that can interface with
                queries that are interchangeable. The goal of this project is to
                bridge the gaps between these different view and data access
                frameworks. 
            </para>
            <figure>
                <title>Projects using Spigot</title>
                <mediaobject>
                    <imageobject role="fo">
                        <imagedata align="center" fileref="../img/app_with_jds.png"
                            scalefit="1" />
                    </imageobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="../img/app_with_jds.png" />
                    </imageobject>
                </mediaobject>
            </figure>


            <para>
                Spigot is divided into three main interfaces which are used to
                fetch data. The
                <classname>Paginator</classname>
                interface defines the state about our dataset such as the order
                information, the page size and the result we are up to. The
                <classname>DataProvider</classname>
                interface defines two simple methods which are used to fetch the
                total number of rows in the complete list of data, and the list
                (or a subset) of items in the dataset. The last interface is the
                <classname>ObjectDataset</classname>
                interface which extends the
                <classname>Paginator</classname>
                interface and adds methods for managing a set of results one
                they have been obtained from the
                <classname>DataProvider</classname>
            </para>
            <example>
                <title>
                    The
                    <classname>DataProvider</classname>
                    interface
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[public interface DataProvider<T> {
  Integer fetchResultCount();
  List<T> fetchResults(Paginator paginator);
}]]>
                    </programlisting>
            </example>
            <para>
                When we fetch the results, we pass in the paginator so the
                <classname>DataProvider</classname>
                implementation knows how many rows to return, where in the
                dataset to start returning rows from and it can also set the
                flag on the paginator indicating whether there are more results
                or not.
            </para>
        </sect1>
        <sect1>
            <title>Benefits of Spigot</title>
            <para>
                Even if you still plan on using a single data access mechanism
                (i.e. Hibernate or JPA) there are still advantages to using
                Spigot.
            </para>

            <sect2>
                <title>Interchangable query mechanisms</title>
                <para>Most projects plan on using only one data access mechanism
                    but by coding to the Spigot API, you can switch
                    implementations later. You might move from JPA to Hibernate
                    or even to plain JDBC queries and most of the code that uses
                    these queries, including parameterized queries and ordering,
                    will remain the same. There may also be times where you need
                    to access different types of data stores such as a file
                    based datasource which needs accessing, paginating and
                    displaying.</para>
                <para>Regardless of where the different types of datastores come
                    from, with Spigot you will be able to access them and
                    control
                    the results using your existing view code to paginate
                    and
                    order the data. Even if you don't see yourself switching
                    data access mechanisms or having to access diverse data
                    stores, you may want to just switch a query here and there
                    from a pure ORM type query to a JDBC SQL query but still
                    want to interface with the data and use the features
                    available in your other queries. </para>
            </sect2>

            <sect2>
                <title>Easy Querying</title>
                <para>Spigot makes it easier to query for the data you need. It
                    features flexible parameter definition by setting the value
                    manually, using EL expressions, extracting the values using
                    reflection or your own custom parameter resolver. Parameters
                    that don't have a value assigned can optionally be left out
                    of the query which can be useful when you are writing search
                    forms where the user may leave out search criteria and you
                    don't want it included in the query. Doing this manually can
                    lead to messy code that is hard to read, test and maintain.
                </para>
                <example>
                    <title>
                        Coding search queries the hard way.
                    </title>
                    <programlisting role="JAVA" language="java">
<![CDATA[String sql = "";
if (searchCriteria.id != null
  && searchCriteria.id.length() != 0) {
    if (sql.length()!= 0) {
      sql = sql + " AND ";
    }
    sql= sql+ "p.id = :id";
    paramsMap("id",searchCriteria.id);
}

if (searchCriteria.firstName != null
  && searchCriteria.firstName.length() != 0) {
    if (sql.length()!= 0) {
      sql = sql + " AND ";
    }
    sql= sql+ "p.firstName = :firstName";
    paramsMap("firstName",searchCriteria.firstName);
}

if (searchCriteria.lastName != null
  && searchCriteria.lastName.length() != 0) {
    if (sql.length()!= 0) {
      sql = sql + " AND ";
    }
    sql= sql+ "p.lastName = :lastName";
    paramsMap("lastName",searchCriteria.lastName);
}

if (sql.length() != 0) {
  sql = " WHERE " + sql;
}
sql = [select statement] + sql;

qry = createQuery(sql);
for (String key : paramsMap.keySet) {
  qry.setParameter(key,paramsMap.get(key))
}

List<Person> results = qry.resultList();]]>
                    </programlisting>

                </example>
                <para>With Spigot, you can define the query, specify how the
                    parameters are resolved and the data provider will take care
                    of generating the right request so that the only
                    restrictions included in the query are ones with parameter
                    values assigned. </para>
                <example>
                    <title>
                        Coding search queries the easy way.
                    </title>
                    <programlisting role="JAVA" language="java">
<![CDATA[qry.addRestriction("p.id = :id");
qry.addRestriction("p.firstName = :firstName");
qry.addRestriction("p.lastName = :lastName");
ParameterResolver resolver =
  new ReflectionParameterResolver(searchCriteria));
qry.addParameterResolver(resolver);
List<Person> results = qry.resultList();]]>
                    </programlisting>
                </example>
            </sect2>


            <sect2>
                <title>Flexible and Secure Ordering Abstraction</title>
                <para>
                    Spigot lets you order your data based on order key values as
                    opposed to explicit table column values which could be prone
                    to SQL injection attacks. By using an
                    <code>orderKey</code>
                    value which is translated server side into a sorting
                    representation, you can control what values are used for
                    setting the order of the dataset ensuring no harmful SQL is
                    inserted into your query.
                </para>
            </sect2>
            <sect2>
                <title>Convert anything into a dataset</title>
                <para>At the heart of Spigot is a simple API which allows you to
                    turn anything into a source of data that can be accessed and
                    paginated from existing view code. This can range from
                    custom datasources or third party applications to text, csv,
                    remote data points, binary files or even just a static
                    in-memory list of objects.</para>
            </sect2>

        </sect1>
        <sect1>
            <title>Architecture</title>
            <para>
                This section covers the architecture of the framework and how
                they all
                relate to each other.</para>
            <sect2>
                <title>Main API</title>
                <para>
                    The main API consists of the
                    <classname>Paginator</classname>
                    and
                    <classname>DataProvider</classname>
                    interfaces. The Paginator is like a bookmark for a dataset
                    and holds the current record index, page size and ordering
                    information as well as flags indicating whether there is a
                    previous or next page available. The
                    <classname>DataProvider</classname>
                    is the stateless part of the equation. It provides the data
                    based on the state of the paginator passed in. For each type
                    of data store you want to access, we write a
                    <classname>DataProvider</classname>
                    implementation for it.
                </para>
                <example>
                    <title>Fetching data from a provider</title>
                    <programlisting role="JAVA" language="java">
<![CDATA[  DataProvider prov = new CustomDataProvider();
  Paginator paginator = new DefaultPaginator();
  List<ResultClass> results = prov.fetchResults(paginator);
  Integer count = prov.getResultCount();]]>
                </programlisting>
                </example>
                <para>
                    This is a simple example where we create an instance of our
                    custom provider that knows how to fetch the data. We create
                    an instance of a
                    <classname>Paginator</classname>
                    and when we fetch the results we pass that in to the data
                    provider to tell the provider which set of data to return.
                    In this case, we returned all the data but by setting
                    properties on the paginator we can tell the provider just to
                    return a subset and which row to start from. The provider is
                    also responsible for setting the
                    <code>nextAvailable</code>
                    flag on the paginator to indicate if there are more results
                    available.
                </para>
                <example>
                    <title>Limiting the data fetched from a data provider
                    </title>
                    <programlisting role="JAVA" language="java">
<![CDATA[  DataProvider prov = new CustomDataProvider();
  Paginator paginator = new DefaultPaginator();
  paginator.setMaxRows(10);
  paginator.setFirstResult(35);
  List<ResultClass> results = prov.fetchResults(paginator);
  Integer count = prov.fetchResultCount();]]>
                </programlisting>
                </example>
                <para>
                    Here we set the maximum number of rows to return to 10 and
                    we want the first result to start at item number 35. The
                    implementation of the
                    <classname>CustomProvider</classname>
                    is responsible for returning the correct subset of data to
                    the caller.
                </para>
                <para>
                    If you were to call
                    <methodname>fetchResults</methodname>
                    a second time, the provider would go off and re-fetch the
                    data executing whatever process it does to fetch the data.
                    It does not cache the data in anyway and should be
                    implemented statelessly such that one call to the provider
                    is independent of any other calls to the provider.
                </para>
                <para>
                    The third part of the API is an
                    <classname>ObjectDataset</classname>
                    which combines both the provider and paginator information
                    into one class and can be used to manage the fetched data.
                    This component should be considered stateful as it holds on
                    to the results and caches them. It also implements the
                    <classname>Iterable</classname>
                    interface to let you iterate over the dataset while taking
                    pagination into account, so while you iterate over each
                    item, they are loaded in a batch at a time based on the
                    <code>maxRows</code>
                    attribute. Datasets implement the
                    <classname>Paginator</classname>
                    interface and have the pagination attributes built in.
                    Datasets have a
                    <code>provider</code>
                    attribute that is used to fetch the actual data so we can
                    re-use our dataset implementation for any kind of data
                    provider. When you change the active page, or the page size
                    or the first result return, this invalidates the interal
                    copy of the current data and causes it to be re-fetched from
                    the provider when it is next requested.
                </para>
                <example>
                    <title>
                        Using an
                        <classname>ObjectDataset</classname>
                    </title>
                    <programlisting role="JAVA" language="java">
<![CDATA[  DataProvider provider = new CustomDataProvider();
  ObjectDataset<SomeClass> dataset = new DataProviderDataset(provider);
  dataset.setMaxRows(10);
  dataset.setFirstResult(35);
  List<ResultClass> results = dataset.getResults();
  for (SomeClass item : dataset) {
    ...some code...
  }]]>  
                </programlisting>
                </example>
                <para>
                    Repeated calls to
                    <methodname>getResults()</methodname>
                    without changing the pagination information will cause the
                    exact same
                    results to be returned since the current page of
                    results is held by the
                    dataset.
                </para>
            </sect2>
        </sect1>
    </chapter>
    <chapter>
        <title>Database Driven Providers</title>
        <para>
            While Spigot offers a way to access many different types of data
            stores, in most cases, you will want to fetch data from a database.
            Spigot comes with data providers for fetching data using JPA,
            Hibernate or just plain SQL via JDBC. These different providers are
            based off and implement the
            <classname>QueryDataProvider</classname>
            interface. This interface adds features such as ordering,
            restrictions and parameters. Since they implement the same
            interface, they can be interchanges with very little code changes if
            any.
        </para>
        <sect1>
            <title>Simple Fetches</title>
            <para>Let's start by considering some simple cases of fetching data
                using a data driven query. First we create the data provider
                that will fetch the data for us and then we create the dataset
                that we will use to access the data.</para>
            <example>
                <title>
                    Fetching data from a database using JPA
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[QueryProvider<Person> provider = new JpaDataProvider<Person>(em);
QueryDataset<Person> dataset = new QueryDataset<Person>(provider);
provider.setSelectStatement("select p from Person p");
provider.setCountStatement("select count(p) from Person p");
List<Person> results = dataset.getResultList();
for (Person p : results) {
  System.out.println(p.getName());
}]]>
                </programlisting>
            </example>
            <para>
                We define a new
                <classname>JpaDataProvider</classname>
                and pass it our
                <classname>EntityManager</classname>
                in the constructor. We create a new
                <classname>QueryDataset</classname>
                that we use to access the data and return the results to us. We
                could do this directly on the provider if we had created a
                <classname>Paginator</classname>
                instance to pass to it. Instead, we let the dataset
                implementation take care of it. We define the select and count
                statements separately since the select statments may contain
                fetch information that is invalid in the count statement.
            </para>
        </sect1>
        <sect1>
            <title>Restricting Results</title>
            <para>We can add restrictions to the query so we only return a set
                of rows that we want. In this case, we want to return people in
                a a specific department. The above code to create and initialize
                the data provider has beem rolled into a method to return the
                person data provider.</para>

            <example>
                <title>
                    Restricting the data fetched
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[QueryDataProvider<Person> provider = createPersonProvider();
provider.addRestriction("p.department.id = 4");  ]]>
                </programlisting>
            </example>


            <para>
                It is often more convenient to specify limitations using
                parameters and Spigot has a number of different mechanisms with
                which to specify parameterized restrictions. First we'll look at
                adding constant parameters. We can add the restriction using the
                keyword
                <code>:param</code>
                where the parameterized value is meant to go and pass the value
                with the restriction. We can also add the restriction with the
                name of the parameter and set the parameter on the data provider
                separately. In the following example, the first two syntaxes
                rename the parameter and put the values in the internal
                parameter map. The last syntax keeps the parameter name you
                passed in and is useful if you anticpate changing that parameter
                since you know what name it can be referenced by.
            </para>
            <example>
                <title>
                    Restricting Results with Constant Parameters
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[QueryDataProvider<Person> provider = createPersonProvider();

//add parameter using :param keyword in restriction
provider.addRestriction("p.department.id = :param",4);
provider.addRestriction("p.firstName = :param","John");

//add parameter manually 
provider.addRestriction("or p.lastName = :lastNameParam");
provider.addParameter("lastNameParam","Smith");]]>
                </programlisting>
            </example>
            <para>
                In many cases, we don't want to include restrictions where the
                parameter value we are using is
                <code>null</code>
                such as search forms where the user has left values blank. In
                these cases, any restriction with null parameter should not be
                included. In this example, we only add the first and last name
                restrictions if the values are set.
            </para>
            <example>
                <title>
                    Restricting with variable parameters
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[QueryDataProvider<Person> provider = createPersonProvider();
provider.addRestriction("p.firstName = :param",searchCriteria.firstName);
provider.addRestriction("p.lastName = :param",searchCriteria.lastName);]]>
                </programlisting>
            </example>
            <para>
                These are really just helper methods so you don't have to do
                your own "
                <code>if value != null then add parameter</code>
                " code for each line, although it is certainly possible that you
                can do that in certain cases. There is also an overloaded
                version of this function specifically for strings which will
                check not only for null values but for a length of zero.
            </para>
            <para>
                Many times you want to evaluate one value to see if is null
                but use another value for the actual parameter to query with. We
                have a method for that too.
            </para>
            <example>
                <title>
                    Alternate Value Parameters
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[QueryDataProvider<Person> provider = createPersonProvider();

provider.addRestriction("p.firstName like :param",
  searchCriteria.firstName,searchCriteria.firstName+"%");

provider.addRestriction("p.lastName like :param",
  searchCriteria.lastName,searchCriteria.lastName+"%");]]>
                </programlisting>
            </example>
            <para>
                We check whether the first/last name value is null and if so
                we ignore the restriction, but otherwise we add the restriction
                and we use the value with a wildcard added as the parameter
                value.
            </para>
            <para>This may seem a fairly broad set of ways to parameterize the
                your queries, but is only the first way of two parameter
                definition mechanisms with the second being the use of parameter
                resolvers.</para>
        </sect1>
        <sect1>
            <title>Parameter Resolvers</title>
            <para>
                The
                <code>ParameterResolver</code>
                interface can be used to implement objects that can be attached
                to data providers at run time to resolve parameters. When the
                query is executed the parameters are evaluated as the query is
                built so any restrictions with
                <code>null</code>
                parameters can be excluded. This mechanism allows us to use
                different parameter resolvers depending on the environment i.e.
                using an EL parameter resolver for EL environments.
            </para>
            <para>It also lets use different mechanisms for resolving values
                such as using reflection onto a an object, or even returning
                parameter values based on the parameter name.</para>
            <example>
                <title>
                    Parameter Resolving with Reflection
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[QueryDataProvider<Person> provider = createPersonProvider();
provider.addRestriction("p.firstName like :firstName");
provider.addRestriction("or p.lastName like :lastName");
provider.addParameterResolver(new ReflectionParameterResolver(searchCriteria));]]>
                </programlisting>
            </example>
            <para>We can also bake the parameter resolver into the criteria
                object directly by making it implement the parameter resolver
                interface. This kind of resolver executes faster than trying to
                resolve EL expressions or use reflection. </para>
            <example>
                <title>
                    Built in parameter resolution
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[public class SearchCriteria implements ParameterResolver {

  //return values with wildcards
  boolean resolveParameter(ParameterizedDataProvider<? extends Object> dataset,
    Parameter parameter) {
    if ("firstName".equals(parameter.getName())) {
      return firstName == null ? null : firstName+"%";
    }
    if ("lastName".equals(parameter.getName())) {
      return lastName == null ? null : lastName+"%";
    }
    return null;
  }

  boolean acceptParameter(String name) {
    return name.startsWith(":");
  }
}
...
...
...
  QueryDataProvider<Person> provider = createPersonProvider();
  provider.addRestriction("p.firstName = :firstName");
  provider.addRestriction("or p.lastName = :lastName");
  provider.addParameterResolver(searchCriteria);]]>
                </programlisting>
            </example>
            <para>
                The Seam and CDI data provider classes use an EL based parameter
                resolver so
                you can use it the same way you would with a Seam
                <classname>EntityQuery</classname>
                .
            </para>

            <example>
                <title>
                    Using the Seam data provider                    
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[@Name("myPostsQuery")
public class MyPostsQueryBean extends SeamJpaQueryDataset{
  public MyPostsQueryBean() {
    setSelectStatement("select p from Posts p left join fetch p.comments");
    setCountStatement("select count(p) from Posts p");    
    addRestriction("p.author.id = #{loggedInUser.id}");
  }
}]]>  
                </programlisting>
            </example>


            <sect2>
                <title>Using your own parameter marker</title>
                <para>
                    You may decide you want to use a custom pattern for
                    parameters
                    in query providers restrictions. By default ':'
                    and '#{....}'
                    are supported for the default and EL parameter
                    patterns. If you
                    decide to have a reflection parameter type
                    starting with '$' you
                    will need to implements you own
                    <classname>ParameterParser</classname>
                    or you can extend the
                    <classname>RegExParameterParser</classname>
                    and override the
                    <methodname>getRegEx()</methodname>
                    method to include '$' signs when parsing. This then needs to
                    be
                    provided to the
                    <classname>DataQueryBuilder</classname>
                    implementation which can be done by overriding the
                    <methodname>createDataQueryBuilder</methodname>
                    method in the query data provider so you can set your
                    parameter
                    parser on the query builder.
                </para>
                <example>
                    <title>Using our own parameter parser.</title>
                    <programlisting role="JAVA" language="java">
<![CDATA[
public class MyCustomJpaDataProvider<T> extends JpaDataProvider<T> {

    @Override
    protected DataQueryBuilder createDataQueryBuilder() {
        DataQueryBuilder  result = super.createDataQueryBuilder();
        result.setParameterParser(new MyCustomParameterParser());
        return result;
    }
}]]>
</programlisting>
                </example>
            </sect2>
        </sect1>

        <sect1>
            <title>Order in the house</title>
            <para>
                Spigot also features key based ordering so rather than specify
                ordering as a set of fields on the dataset, you can specify
                ordering using a key that maps to one or more fields. </para>
            <example>
                <title>
                    Ordering on the data
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[QueryDataProvider<Person> provider = createPersonProvider();
provider.addRestriction("p.lastName = 'SMITH'");
provider.getOrderKeyMap().put("name","p.lastName,p.firstName");
provider.getOrderKeyMap().put("age","p.dateOfBirth");
provider.getOrderKeyMap().put("id","p.id");
//now set the order
Paginator paginator = new DefaultPaginator();
paginator.setOrderKey("name");  //order by the persons name
paginator.setOrderAscending(false);

List<Person> orderedList = provider.fetchResults(paginator):]]>
                </programlisting>
            </example>
            <para>
                The order information consists of the
                <code>orderKey</code>
                attribute that indicates the order to use and the
                <code>orderAscending</code>
                attribute indicates whether it is meant to be ascending or
                descending. Both of these attributes are on the
                <classname>Paginator</classname>
                interface and are read when it is passed into the
                <methodname>fetchResults</methodname>
                method.
                Note that in this example, the ordering for the key
                "name" has two fields, last and first name to sort on. If this
                key is used to order then both these fields will be used to
                order and the framework takes care of ascending/descending
                issues.
            </para>
            <para>
                By abstracting the ordering mechanism we can use the same idea
                for defining ordering on non-database data providers. The key
                for example might map to a
                <classname>Comparator</classname>
                instance that can be used to sort the in-memory dataset.
            </para>
        </sect1>
        <sect1>
            <title>Polymorphism</title>
            <para>
                One of the best features here is that in order to switch from
                Hibernate to JPA, or another data driven implementation, all we
                need to change is our
                <methodname>createPersonProvider()</methodname>
                method. Following good principles, we have been coding to an
                interface and not an actual class type so we are not locked in
                to using a concrete class, but any class that implements the
                <classname>QueryDataProvider</classname>
                interface. Currently, there are
                <classname>QueryDataProvider</classname>
                implementations for SQL/JDBC, Hibernate and JPA. The JPA
                versions include both Ejbql and Native querying as do the Seam
                extensions for the JPA providers.
            </para>
            <para>
                You could easily return a Hibernate data provider from the
                <methodname>createPersonProvider</methodname>
                without having to change any code since the mappings will be the
                same. At most you might have to change the base select/count
                statement or any complex where clauses.
            </para>
        </sect1>
        <sect1>
            <title>Mapping SQL to Objects</title>
            <para>One problem so far is that our data providers always deal with
                objects natively because that is what Hibernate and JPA do. Our
                SQL based datasets are fetching data as a set of rows of values
                instead of actual objects so we still need some way to convert
                that raw data into an object that can be returned in our
                results.
            </para>
            <para>
                This can be done in one of two ways but both involve a
                <classname>java.sql.ResultSet</classname>
                and building an instance of our model objects from the current
                row of data.
            </para>
            <para>
                The first method is to subclass the
                <classname>AbstractJdbcDataProvider</classname>
                and override the
                <methodname>createObjectFromResultSet</methodname>
                method. This uses the template pattern to provide the missing
                functionality needed to convery SQL data into an actual object.
            </para>
            <example>
                <title>
                    Implementing the SQL to Object mapping
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[public class PersonDataProvider extends
    AbstractJdbcDataprovider<Person> {
  public T createObjectFromResultSet(ResultSet resultSet) throws SQLException {
    return new Person(resultSet.getLong(1), resultSet.getString(2),
        resultSet.getString(3));
  }
}  ]]>
                </programlisting>
            </example>
            <para>
                Some people prefer to use a strategy pattern over a template
                pattern so we have an implementation for that also. The
                <classname>ResultSetObjectMapper</classname>
                interface provides a method to take a
                <classname>javax.sql.ResultSet</classname>
                and return an object for the current row in the results. The
                <classname>JdbcDataProvider</classname>
                class takes a reference to a
                <classname>ResultSetObjectMapper</classname>
                instance and uses it to convert the raw SQL rows to an object.
            </para>

            <example>
                <title>
                    SQL to Object mapping using an external mapper.
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[public class PersonObjectMapper implements
    ResultSetObjectMapper<Person> {

  public Person createObjectFromResultSet(ResultSet resultSet)
    throws SQLException {
    return new Person(resultSet.getLong(1),resultSet.getString(1),
      resultSet.getString(2));
    }
}

public QueryDataProvider<Person> createDataProvider() {
  JdbcDataProvider<Person> prov = new JdbcDataProvider<Person>();
  prov.setResultSetObjectMapper(new PersonObjectMapper());
  return prov;
}]]>
                </programlisting>
            </example>
            <para>This kind of construction can be taken care of by any
                dependency
                injection framework you are using.</para>
        </sect1>

    </chapter>
    <chapter>
        <title>Implementing and Testing a Data Provider</title>
        <para>This chapter looks at creating a simple data provider, testing it
            and seeing the different ways we can access the data in it.</para>
        <sect1>
            <title>
                Our first
                <classname>DataProvider</classname>
            </title>
            <para>
                Let us start by seeing how the different parts and pieces
                connect by creating a new provider that lists the numbers from 1
                to 100 and we will access it in different ways. We'll start by
                writing our data provider that implements the
                <classname>DataProvider&lt;Integer&gt;</classname>
                interface.
            </para>
            <example>
                <title>
                    <code>IntegerDataProvider.java</code>
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[public class IntegerDataProvider implements DataProvider<Integer>,
    Serializable {

  public Integer fetchResultCount() {
    return 100;
  }

  public List<Integer> fetchResults(Paginator paginator) {

    int start = paginator.getFirstResult();

    int end = paginator.includeAllResults() ? 100 :
      Math.min(100, start+paginator.getMaxRows().intValue()-1);

    List<Integer> results = new ArrayList<Integer>();
    System.out.println("Generating results from "+start+" to "+end);
    while (start <= end) {
      results.add(start++);
    }
    paginator.setNextAvailable(end < 100);
    return results;
  }
}]]>
            </programlisting>
            </example>
            <para>
                The
                <methodname>fetchResultCount()</methodname>
                method returns a constant value of 100 in this case because we
                are dealing with a fixed range of integers. Typically though,
                this will return the number of items in the complete dataset and
                is used to determine the number pages available.
            </para>
            <para>
                The
                <methodname>fetchResults</methodname>
                methods takes a paginator and generates the list of integers to
                return to the user. The list is based on two things, the
                <code>firstResult</code>
                value that determines which page we are on and therefore where
                to start counting from, and the
                <code>maxRows</code>
                value that determines how many results to return. If
                <code>maxRows</code>
                is set to null then we are returning all rows, and we have the
                utility method
                <methodname>includeAllResults</methodname>
                to make it easier to check this. Once we have determined the
                start and end points to count from and to, we build the list of
                results, and before returning it, we set the flag for indicating
                whether there are more results available. This is the
                responsibility of the data provider because only it knows
                whether there are more results.
            </para>
            <para>Next, we'll create a client for this provider as a simple
                class that just fetches the results and lists them.</para>
            <example>
                <title>
                    <code>IntegerDataProvider.java</code>
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[public class Main {

    public static void main(String[] args) {
        Paginator paginator = new DefaultPaginator(10);
        DataProvider<Integer> provider = new IntegerDataProvider();

        List<Integer> results = provider.fetchResults(paginator);
        showResults(results);
    }

    public static void showResults(List<Integer> results) {
        System.out.println("Result Size = " + results.size());

        for (Integer i : results) {
            System.out.println("Value = " + i);
        }
    }
}]]>
</programlisting>
            </example>

            <para>
                In the
                <methodname>main</methodname>
                method, we create a new
                <classname>DefaultPaginator</classname>
                instance that implements the
                <classname>Paginator</classname>
                interface. We pass our initial page size into the constructor so
                we will start by returning 10 rows at a time. We then create an
                instance of our data provider, and call the
                <methodname>fetchResults</methodname>
                method to return the first page of results. We then pass the
                results to the
                <methodname>showResults</methodname>
                method which just displays the number of results. If we run
                this, we get the expected list of numbers from 0 to 9 with a
                page size of 10.
            </para>
            <figure>
                <title>
                    Execution Results
                </title>
                <screen>
<![CDATA[Generating results from 0 to 9
Result Size = 10
Value = 0
Value = 1
Value = 2
Value = 3
Value = 4
Value = 5
Value = 6
Value = 7
Value = 8
Value = 9]]>
</screen>
            </figure>
            <para>So everthing looks fine, this is the result we expected so we
                must have a working dataset right? Well not so fast. Let's
                create a test case for it first. Since we are working with well
                defined interfaces we can define a test case that tests the
                interface and make sure our implementation is meeting the
                contract defined by the interface.</para>
        </sect1>
        <sect1>
            <title>
                Testing our
                <classname>DataProvider</classname>
            </title>
            <para>
                Create a new class (in the test packages if applicable) and
                create it as a subclass of
                <classname>org.fluttercode.spigot.testing.junit.AbstractObjectDatasetJUnitTest
                </classname>
                This class defines two methods which needs to be implemented in
                subclasses. The
                <methodname>getDataRowCount()</methodname>
                returns the number of rows expected in the dataset and the
                <methodname>buildObjectDataset</methodname>
                method returns an instance of an
                <classname>ObjectDataset</classname>
                An
                <classname>ObjectDataset</classname>
                is a class that combines a
                <classname>Paginator</classname>
                and a
                <classname>DataProvider</classname>
                implementation in one class for convenience. We can easily
                create one by creating an instance of a
                <classname>org.fluttercode.spigot.impl.Dataset</classname>
                and pass it an instance of our
                <classname>IntegerDataProvider</classname>
                which the dataset will use to obtain data.
            </para>

            <example>
                <title>
                    <code>IntegerDataProvider.java</code>
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[public class IntegerDataProviderTest extends
  AbstractObjectDatasetJUnitTest<Integer> {

    @Override
    public ObjectDataset<Integer> buildObjectDataset() {
        DataProvider<Integer> provider = new IntegerDataProvider();
        return new Dataset<Integer>(provider);
    }

    @Override
    public int getDataRowCount() {
        return 100;
    }

}]]>
</programlisting>
            </example>
            <para>If you run this test case now, you will see things light up
                like a Christmas tree. We have a lot of tests failing in some
                code that not only looked ok, but worked fine when we ran it.
            </para>
            <para>
                The problem is subtle but involves on the old gotcha there are
                101 numbers from 0 to 100 inclusive. The solution is fairly
                simple, we just need to define more closely what our dataset
                does. We'll make it so that it does return 100 values in the
                range from 1 to 100, and we'll even add some test cases to
                ensure that it does. First lets alter the
                <methodname>fetchResults</methodname>
                method in our
                <classname>IntegerDataProvider</classname>
                class.
            </para>

            <example>
                <title>
                    Revised
                    <methodname>fetchResults</methodname>
                    method in
                    <code>IntegerDataProvider.java</code>
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[
public List<Integer> fetchResults(Paginator paginator) {

  int start = paginator.getFirstResult()+1; //results start from 1

  int end = paginator.includeAllResults() ? 100 :
  Math.min(100, start+paginator.getMaxRows().intValue()-1);

  List<Integer> results = new ArrayList<Integer>();
  System.out.println("Generating results from "+start+" to "+(end));
  while (start <= end) {
    results.add(start++);
  }
  paginator.setNextAvailable(end < 100);
  return results;
}]]>
</programlisting>
            </example>
            <para>
                If you run the tests now you should almost pass with flying
                colors even though we only made very small changes. The test
                that failed is the serialization test to determine if a dataset
                holding our data provider can be serialized. In this case, it
                cannot because we have not implemented the
                <classname>Serializable</classname>
                interface in the dataprovider. If you add this interface to the
                <classname>IntegerDataProvider</classname>
                class name and rerun the tests, it should pass with no problems.
                The serializable test is there as a helper because so many
                frameworks now depend on serializable components (Spring MVC,
                Wicket, CDI and Seam) and raises errors if there are
                serializable issues. If you do not need the dataset to be
                serializable or it cannot be made serializable, you can turn off
                this test by overriding the
                <methodname>includeSerializationTest()</methodname>
                and returning false.
            </para>
            <para>The base test classes provide fairly good code coverage and
                can only get better over time as more tests are added. Even
                without writing any test cases yourself you are already off to a
                good start in determining how well you data provider code is
                written.
            </para>
            <para>
                The
                <classname>AbstractObjectDatasetJUnitTest</classname>
                can only test how well the dataset lives up to its
                implementation of the
                <classname>DataProvider</classname>
                interface, it cannot test the quality of the results. For that,
                we need to add our own tests to our class which we'll do now for
                the constraint that the numbers should range from 1 to 100. We
                will test it in two ways, paginated and non-paginated.
            </para>

            <example>
                <title>
                    Additional tests in
                    <classname>IntegerDataProviderTest.java</classname>
                    to validate the results returned.
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[
public void testResultsPaginated() {
  ObjectDataset<Integer> ds = buildObjectDataset();
  ds.setMaxRows(10);
  Integer expected = 1;
  while (ds.isNextAvailable()) {
    List<Integer> results = ds.getResultList();
    for (Integer i : results) {
      assertEquals(expected, i);
      expected = expected + 1;
    }
    ds.next();
  }

}

public void testResultsIterated() {
  ObjectDataset<Integer> ds = buildObjectDataset();
  ds.setMaxRows(10);
  Integer expected = 1;
  for (Integer i : ds) {
    assertEquals(expected, i);
    expected = expected + 1;
  }
}

public void testResultsNonPaginated() {
  ObjectDataset<Integer> ds = buildObjectDataset();
  ds.setMaxRows(null);
  Integer expected = 1;
  List<Integer> results = ds.getResultList();
  assertEquals(100, results.size()); //check size
  for (Integer i : results) {
    assertEquals(expected, i);
    expected = expected + 1;
  }
}]]>
</programlisting>
            </example>
            <para>Again, running these tests should provide a clean set of test
                results.
   </para>
        </sect1>
        <sect1>
            <title>
                Using our
                <classname>DataProvider</classname>
            </title>
            <para>
                We can now be pretty confident that our dataset works as
                expected with dozens of test cases behind it. Now we can go back
                to our
                <classname>Main</classname>
                class and start seeing how we access the data provided by this
                class.
            </para>
            <para>
                Data can be accessed from a provider in a number of ways, either
                paginated, non-paginated or using iterators paginated or
                non-paginated). In our original example, we simply listed the
                first 10 results. From the test code you might have seen a few
                more ways of accessing the data. First lets change our demo
                application to use an
                <classname>ObjectDataset</classname>
                instead of keeping separate
                <classname>Paginator</classname>
                and
                <classname>DataProvider</classname>
                references. The
                <classname>ObjectDataset</classname>
                combines these two interfaces and provides some benefits as
                we'll see.
            </para>
            <example>
                <title>
                    Changing our demo application to use an
                    <classname>ObjectDataset</classname>
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[public static void main(String[] args) {
    ObjectDataset<Integer> ds = new Dataset<Integer>(new IntegerDataProvider());
    ds.setMaxRows(5);

    List<Integer> results = ds.getResultList();
    showResults(results);
}]]>
</programlisting>
            </example>
            <para>If you run this now, it should run the same as before except
                for the fact that we changed the page size to 5 so we only
                return 5 rows at a time for brevity. Let's add a second call to
                fetch the list of results and we'll see what happens.</para>
            <example>
                <title>
                    Changing our demo application to use an
                    <classname>ObjectDataset</classname>
                </title>
                <programlisting role="JAVA" language="java">
<![CDATA[public static void main(String[] args) {
    DataProvider<Integer> provider = new IntegerDataProvider();
    ObjectDataset<Integer> ds = new Dataset<Integer>(provider);
    ds.setMaxRows(5);

    List<Integer> results = ds.getResultList();
    showResults(results);
    showResults(ds.getResultList());
}]]>
</programlisting>
            </example>
            <figure>
                <title>Demo application results</title>
                <screen>            
Generating results from 1 to 5
Result Size = 5
Value = 1
Value = 2
Value = 3
Value = 4
Value = 5
Result Size = 5
Value = 1
Value = 2
Value = 3
Value = 4
Value = 5
</screen>
            </figure>
            <para>
                Unsurprisingly, we display the same list of numbers twice, but
                what is surprising is that we only generate the results the
                first time they are requested. The second time we call for the
                results, there is no message about generating results. This is
                because the
                <classname>ObjectDataset</classname>
                caches the results and only invalidates them when the pagination
                changes i.e. the first result or page size is changed). You can
                manually force the results to be refreshed by calling
                <methodname>invalidateResults()</methodname>
                on the dataset. Doing so after the first call would force the
                dataset to re-fetch the data on the second call.
            </para>
            <para>
                This is one of the benefits of using a dataset on a thicker
                client or a stateful web app. The dataset can hold on to the
                results for you until you are done with them. Using separate
                <classname>Paginator</classname>
                and
                <classname>DataProvider</classname>
                instances can be useful in more stateless applications, or
                frameworks like Wicket that uses a detachable model that keeps
                hold of state, but lets you detach unwanted or re-fetchable
                state.
            </para>
            <sect2>
                <title>I want it all</title>
                <para>
                    You can fetch all the results in the dataset by settings the
                    <code>maxRows</code>
                    to
                    <code>null</code>
                    . This means that when you call
                    <code>getResults</code>
                    you will get all the results from the
                    <code>firstResult</code>
                    index to the end. When you create a
                    <classname>ObjectDataset</classname>
                    by default, it is set up to fetch results from the first row
                    and is not paginated so it will return all results from the
                    beginning to the end.
                </para>
                <example>
                    <title>Returning all results</title>
                    <programlisting role="JAVA" language="java">
<![CDATA[public static void main(String[] args) {
    DataProvider<Integer> provider = new IntegerDataProvider();
    ObjectDataset<Integer> ds = new Dataset<Integer>(provider);
    showResults(ds.getResultList());
}]]>
</programlisting>
                </example>
                <figure>
                    <title>Returning all results</title>
                    <screen>
Generating results from 1 to 100
Result Size = 100
Value = 1
Value = 2
Value = 3
Value = 4
Value = 5
Value = 6
Value = 7
...
...
...
Value = 98
Value = 99
Value = 100
</screen>
                </figure>
            </sect2>
            <sect2>
                <title>Iteratively Speaking</title>
                <para>
                    The dataset implements the
                    <classname>Iterable</classname>
                    interface which means that we can iterate over the dataset.
                    If pagination is in use, it is performed transparently as
                    you iterate through the dataset.
                </para>
                <example>
                    <title>Returning all results</title>
                    <programlisting role="JAVA" language="java">
<![CDATA[public static void main(String[] args) {
    DataProvider<Integer> provider = new IntegerDataProvider();
    ObjectDataset<Integer> ds = new Dataset<Integer>(provider);
    ds.setMaxRows(5);
    for (Integer i : ds) {
        System.out.println("Iterating over value "+i);
    }       
}]]>
</programlisting>
                </example>
                <figure>
                    <title>Iterating over a paginated dataset</title>
                    <screen>
Generating results from 1 to 5
Iterating over value 1
Iterating over value 2
Iterating over value 3
Iterating over value 4
Iterating over value 5
Generating results from 6 to 10
Iterating over value 6
Iterating over value 7
Iterating over value 8
Iterating over value 9
Iterating over value 10
Generating results from 11 to 15
Iterating over value 11
Iterating over value 12
...
...
...
terating over value 89
Iterating over value 90
Generating results from 91 to 95
Iterating over value 91
Iterating over value 92
Iterating over value 93
Iterating over value 94
Iterating over value 95
Generating results from 96 to 100
Iterating over value 96
Iterating over value 97
Iterating over value 98
Iterating over value 99
Iterating over value 100                            
</screen>
                </figure>
                <para>This could be useful in cases where you want to group
                    fetches into batches if fetches are expensive, or maybe even
                    incorporate some multi-threading to let one thread fetch
                    data and other threads to process result sets as they come
                    in.
                </para>
            </sect2>
            <sect2>
                <title>Paging Datasets</title>
                <para>Generally paging through a dataset is done using the next
                    and previous which changes the subset of data you are
                    looking at. Generally speaking, using the iterator is the
                    best way to iterate over every item in the dataset since
                    paging is generally used to move to a specific page as to
                    iterate through the data. </para>
                <para>Iterating manually is fraught with corner cases that could
                    lead to a number of errors.</para>

                <example>
                    <title>Attempting manual iteration</title>
                    <programlisting role="JAVA" language="java">
<![CDATA[//BROKEN CODE, DO NOT USE
while (ds.isNextAvailable()) {
    List<Integer> res = ds.getResultList();
    showResults(res);
    ds.next();
}]]>
</programlisting>
                </example>
                <para>
                    What happens here is that when we move to the last page
                    using next, the
                    <methodname>nextAvailable</methodname>
                    property is set to false and we exit the loop before we
                    display it. We could process the results after the loop but
                    what happens when you forget to add the code at the end? The
                    best demonstration of this is where the size of the result
                    set is smaller than the page size, and when we fetch the
                    first page of results,
                    <methodname>nextAvailable</methodname>
                    is false since this is the first and only page, and so we
                    don't display the list.
                </para>
                <para>
                    In general, use the dataset next/previous/first/last methods
                    to navigate the dataset by moving from page to page and the
                    <classname>Iterator</classname>
                    implementation to go through the dataset item by item
                    <superscript>*</superscript>
                    . The iterator implementation handles all the corner cases
                    in a familiar and consistent manner.
                </para>
                <para>
                    Note that in the event of you reaching the end of the
                    dataset and calling next, the active page will not change
                    and you will receive the last result set back. Unless the
                    dataset is empty, there will always be results returned in
                    the result list, and if there are no results, an empty list
                    should be returned. The results should never be
                    <code>null</code>
                    .
                </para>
                <note>
                    <para>
                        <superscript>*</superscript>
                        We do use this kind of incorrect paging through data in
                        some of the test cases, but only where we are not
                        testing the number of results, but the actual result
                        content, and we want to test the
                        first/next/previous/last methods as opposed to the
                        iterator implementation.
                    </para>
                </note>
            </sect2>
            <sect2>
                <title>Manually Fetching Data</title>
                <para>
                    The
                    <classname>ObjectDataset</classname>
                    is a helper construct that manages the two key interfaces of
                    the
                    <classname>Paginator</classname>
                    and
                    <classname>DataProvider</classname>
                    . It is easy to use these two classes separately since there
                    is no complex glue code implemented by the
                    <classname>ObjectDataset</classname>
                    except where it has provided enhanced features. Using two
                    separately instantiated pagiantors and providers is
                    straightforward :
                </para>

                <example>
                    <title>Manually creating provider and pagination instances
                        and
                        fetching
                        results</title>
                    <programlisting role="JAVA" language="java">
<![CDATA[DataProvider<Integer> provider = new IntegerDataProvider();
Paginator paginator = new SimplePaginator(10);
List<Integer> results = provider.fetchResults(paginator);
showResults(results);           ]]>
</programlisting>
                </example>
                <para>
                    Each call to
                    <methodname>fetchResults</methodname>
                    executes the process to fetch the data. This can mean
                    running a database query or parsing a file. The results are
                    not cached unlike the
                    <classname>ObjectDataset</classname>
                    . This is because the
                    <classname>DataProvider</classname>
                    and
                    <classname>Paginator</classname>
                    instances are the raw building blocks that make up the
                    <classname>ObjectDataset</classname>
                </para>
                <para>
                    One important thing to bear in mind with using these
                    components manually is that the
                    <classname>DataProvider</classname>
                    implementation is responsible for setting the
                    <code>nextAvailable</code>
                    property on the
                    <classname>Paginator</classname>
                    instance passed in to the
                    <methodname>fetchResults</methodname>
                    method. This means that when you first create a paginator,
                    the
                    <methodname>isNextAvailable</methodname>
                    value is false so you cannot create a new paginator instance
                    and call the
                    <methodname>next()</methodname>
                    method since it, as well as other functions, depends on the
                    <code>nextAvailable</code>
                    flag.
                </para>
                <para>One benefit of using these standalone components manually
                    is that you can use multiple paginator instances to provide
                    different views of the same dataset independent of each
                    other. This can be useful when you want application scoped
                    data with local pagination.
                </para>
                <example>
                    <title>Multiple views of the same data</title>
                    <programlisting role="JAVA" language="java">
<![CDATA[DataProvider<Integer> provider = new IntegerDataProvider();
Paginator paginator1 = new DefaultPaginator(10);
Paginator paginator2 = new DefaultPaginator(15);
paginator1.setFirstResult(20);
paginator2.setFirstResult(30);

System.out.println("First result = "+paginator1.getFirstResult());

List<Integer> results1 = provider.fetchResults(paginator1);
List<Integer> results2 = provider.fetchResults(paginator2);
System.out.println("Result Set 1");
showResults(results1);
System.out.println("Result Set 2");
showResults(results2);]]>
</programlisting>
                </example>
                <para>Here we obtain two different sets of data from a single
                    data provider. This can let you re-use data providers that
                    obtain data from expensive data sources.</para>
            </sect2>

        </sect1>
    </chapter>

    <chapter>
        <title>The Spigot Architecture</title>
        <para>
            Now we've covered these fundamentals of using Spigot we can look at
            the different subclasses of the
            <classname>DataProvider</classname>
            interface and implementations so we create datasets that can attach
            to different datasources in a useful way.
        </para>
        <sect1>
            <title>Data Provider Types</title>
            <para>
                Most subclasses of the
                <classname>DataProvider</classname>
                are mirrored in some form of
                <classname>ObjectDataset</classname>
                subclass which acts as a thick client wrapper around the data
                provider and internally uses an instance of that particular
                subclass.
            </para>
            <sect2>
                <title>
                    <classname>ParameterizedDataProvider</classname>
                </title>
                <para>
                    The first subclass of the
                    <classname>DataProvider</classname>
                    interface is the
                    <classname>ParameterizedDataProvider</classname>
                    that introduces methods for using dynamic parameters to
                    provide parameterization features on datasets that were
                    non-sql based. For example, in a data provider that features
                    file listings, you could have a directory parameter that
                    indicates the directory to list files from.
                </para>
            </sect2>

            <sect2>
                <title>
                    <classname>StatementDataProvider</classname>
                </title>
                <para>
                    The
                    <classname>StatementDataProvider</classname>
                    extends the
                    <classname>ParameterizedDataProvider</classname>
                    and adds the ability to define string based statements for
                    fetching and counting the number of rows of data. Since this
                    extends the
                    <classname>ParameterizedDataProvider</classname>
                    we can let the user define statements that have parameters
                    within them. This obviously lends itself to easily providing
                    the bulk of features of a Sql or Ejbql or Hql data provider.
                </para>
            </sect2>
            <sect2>
                <title>
                    <classname>QueryDataProvider</classname>
                </title>
                <para>
                    The
                    <classname>QueryDataProvider</classname>
                    extends the
                    <classname>StatementDataProvider</classname>
                    and adds the ability to define restrictions and ordering.
                    This class is really intended for targeting data stores that
                    have a SQL-like query language which can be parameterized.
                </para>
            </sect2>

            <sect2>
                <title>
                    <classname>AbstractQlDataProvider</classname>
                </title>
                <para>
                    This class provides the hooks for implementing the data
                    fetch using a query language such as Sql or Ejbql. It does
                    this by using an intermediate
                    <code>DataQuery</code>
                    object that contains the state of the query in an
                    implementation-neutral manner. Subclasses then use the
                    <classname>DataQuery</classname>
                    to query the database using their specific data access
                    mechanism.
                </para>
            </sect2>
            <sect2>
                <title>
                    <classname>AbstractQueryDataProvider</classname>
                </title>
                <para>
                    This class extends the
                    <classname>AbstractQlDataProvider</classname>
                    and implements the
                    <classname>QueryDataProvider</classname>
                    interface. It handles the creation of the
                    <classname>DataQuery</classname>
                    using a
                    <classname>DataQueryBuilder</classname>
                    instance. This builder takes a statement and restrictions
                    and resolves the parameters and generates the final
                    <classname>DataQuery</classname>
                    . This query is then executed in the subclasses using the
                    particular data access mechanism specific to that
                    implementation. This class assumes only that there is a
                    select and a count statement, and uses that to generate the
                    query. The restrictions are introduced to the hierarchy and
                    used in the query building later.
                </para>
            </sect2>
        </sect1>
        <sect1>
            <title>
                <classname>ObjectDataset</classname>
                Types
            </title>
            <para>
                <classname>ObjectDataset</classname>
                instances can help when using the data provider in a stateful
                manner. The dataset holds the current page of results (or the
                whole result set if there are no limits on the rows returned).
                The basic
                <classname>Dataset</classname>
                class takes a
                <classname>DataProvider</classname>
                implementation as its data provider. However, this can lead to
                code requiring a lot of casting for a data provider that extends
                <classname>DataProvider</classname>
                and has custom attributes or methods, including extensions like
                <classname>QueryDataProviders</classname>
                .
            </para>
            <example>
                <title>Poorly typed provider and dataset useage</title>
                <programlisting role="JAVA" language="java">
<![CDATA[  QueryDataProvider<Person> provider = new JpaQueryProvider<Person>();
DataProviderDataset<Person> dataset = new DataProviderDataset<Person>(provider);

//
// Won't work, getProvider returns a DataProvider,
// not a query data provider.  DataProvider doesn't
// have the query data provider methods on there.
//
//dataset.getProvider().addRestriction("p.id = :param",300);

// Casting required
((JpaQueryProvider<Person>) dataset.getProvider()).addRestriction(
    "p.id = :param",300);]]>
</programlisting>
            </example>
            <para>
                Rather than force the user to keep type casting the provider,
                there is a generic implementation of the dataset that takes the
                type of data provider it uses as a parameter. This lets you call
                the
                <methodname>getProvider()</methodname>
                in a type safe manner.
            </para>
            <example>
                <title>Strongly typed data provider and dataset usage</title>
                <programlisting role="JAVA" language="java">
<![CDATA[QueryDataProvider<Person> provider;
Dataset<Person,QueryDataProvider<Person>> dataset;

provider = new JpaQueryProvider<Person>();
dataset = new Dataset<Person,QueryDataProvider<Person>>(provider);
dataset.getProvider().init(Person.class, "p");
dataset.getProvider().addRestriction("p.id = #{personSearch.id}");
dataset.getProvider().addParameterResolver(new MyParameterResolver());]]>
</programlisting>
            </example>
            <para>
                This is further extended by creating implementations for the
                different type of query interfaces we use. In this example,
                rather than create a generic
                <classname>Dataset</classname>
                with the provider class type as a generic type parameter,
                there
                is a
                <classname>QueryDataset</classname>
                type that extends the
                <classname>Dataset</classname>
                and sets the provider type parameter to
                <classname>QueryDataProvider&lt;T&gt;</classname>
                . This class also means we don't have to provide the type
                parameter.
            </para>
            <example>
                <title>Type safety with the QueryDataProvider</title>
                <programlisting role="JAVA" language="java">
<![CDATA[  QueryDataProvider<Person> provider = new JpaQueryProvider<Person>();
  QueryDataset<Person> dataset = new QueryDataset<Person>(provider);
  dataset.getProvider().init(Person.class, "p");
  dataset.getProvider().addRestriction("p.id = #{person.id}");]]>
</programlisting>
            </example>
            <para>
                We still maintain polymorphism because the
                <classname>QueryDataset</classname>
                implementation can take any data provider that implements the
                <classname>QueryDataProvider</classname>
                such as the JPA, Hibernate or SQL providers.
            </para>
        </sect1>
        <sect1>
            <title>
                <classname>ObjectDataset</classname>
                Usage
            </title>
            <para>
                You might find yourself using the stateful
                <classname>ObjectDataset</classname>
                most of the time. Even in web applications where you might have
                a stateless page, when rendering the page, the method to return
                the query results might be called a number of times as it is
                rendered. If you used a data provider to obtain the results,
                they would have to be regenerated on each call (unless you
                manually held the results somewhere). Using a dataset to hold
                the results will make the results stateful, even if only for the
                duration of the web request. This same feature could be used in
                other stateless web environments. There is little overhead in
                using an
                <classname>ObjectDataset</classname>
                implementation instead of separate provider and paginator
                instances.
            </para>
            <para>If you use Seam, Spring web flow, CDI or other frameworks that
                allow state to last beyond the current request, or even just
                putting it in the session, you can extend the life of the query
                over multiple requests which will save you having to re-query
                the data next time it is needed. </para>
            <sect2>
                <title>Choosing a Dataset</title>
                <para>
                    It may seem a litt confusing at first that there are so many
                    datasets and providers. The primary thing to remember is
                    that there is only one dataset interface (
                    <classname>ObjectDataset</classname>
                    ) and one concrete implementation (
                    <classname>Dataset</classname>
                    which does extend the
                    <classname>AbstractDataset</classname>
                    which in turn implements the
                    <classname>ObjectDataset</classname>
                    interface. The
                    <classname>Dataset</classname>
                    implementation is generic and can be used with any provider
                    as long as you specify the type as a generic type parameter.
                    If you want a dataset that can accept any
                    <classname>DataProvider</classname>
                    implementation, then you can use the
                    <classname>DataProviderDataset</classname>
                    class which just requires the type of object the provider
                    returns.
                </para>
                <para>The following examples are all pretty much identical, the
                    only difference is the level of polymorphism available in
                    each of the dataset values. </para>
                <example>
                    <title>
                        Basic
                        <classname>ObjectDataset</classname>
                        types
                    </title>
                    <programlisting role="JAVA" language="java">
<![CDATA[  

DataProvider<Widget> provider1 = createJpaDataProvider();
JpaDataProvider<Widget> provider2 = createOtherJpaDataProvider();

ObjectDataset<Widget> ds1 = new Dataset<Widget,DataProvider<Widget>>(provider1);

DataProviderDataset<Widget> d2 = new DataProviderDataset<Widget>(provider2);
ObjectDataset<Widget> ds3 = new JpaDataset<Main>(provider2);
Dataset<Main, QueryDataProvider<Main>> ds4 = new QueryDataset<Main>(provider2);
]]>
</programlisting>
                </example>
                <para>We extend this to implement Parameterized, Statement and
                    Query dataset that accept Parameterized, Statement and query
                    data providers respectively. Again, this has the benefit of
                    not forcing you to specify the specific type of data
                    provider you want to use. This has the added benefit of
                    steering developers into good practices since it coerces
                    them to use the more general interface types as opposed to
                    specifying the exact type used.</para>
                <example>
                    <title>
                        Using the
                        <classname>Dataset</classname>
                        extensions
                    </title>

                    <programlisting role="JAVA" language="java">
<![CDATA[JpaDataProvider<Widget> provider = createQueryDataProvider();

ObjectDataset<Widget> ds1 = new Dataset<Widget, DataProvider<Widget>>(provider);
DataProviderDataset<Widget> ds2 = new DataProviderDataset<Widget>(provider);        
Dataset<Widget,QueryDataProvider<Widget>> ds3 = new Dataset<Widget,QueryDataProvider<Widget>>(provider);        
QueryDataset<Widget> ds4 = new QueryDataset<Widget>(provider);
JpaDataset<Widget> ds5 = new  JpaDataset<Widget>(provider);
]]>
        
</programlisting>
                </example>
                <para>
                    We created a specific type of data provider, and yet we
                    can
                    use it with different types of dataset. The datasets we
                    have
                    used here are in order of increasing specificity,
                    starting
                    with the least specific
                    <classname>ObjectDataset</classname>
                    .
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            The
                            <classname>ObjectDataset</classname>
                            is the simplest type of dataset. It will allow
                            pagination but no access to the underlying data
                            provider.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The
                            <classname>DataProviderDataset</classname>
                            is a dataset that works off a data provider and it
                            gives you access to that data provider as a basic
                            <classname>DataProvider</classname>
                            type.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            This
                            <classname>Dataset</classname>
                            type takes a specific provider type as a parameter
                            so it will return the right type in the
                            <methodname>getProvider</methodname>
                            method. Here is it using the more generic
                            <classname>QueryDataProvider</classname>
                            as the provider type so the provider type
                            accessed
                            from the
                            <methodname>getProvider</methodname>
                            method is typed to the
                            <classname>QueryDataProvider</classname>
                            . However, this dataset can accept any provider that
                            implements the
                            <classname>QueryDataProvider</classname>
                            interface and is useful if you want to switch out
                            the provider implementation later. However, this
                            class requires a type parameter so it less concise.

                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The
                            <classname>QueryDataset</classname>
                            version is identical to the previous
                            <classname>Dataset</classname>
                            version except that you don't need to specify the
                            type parameter since it is defined in the
                            <classname>QueryDataset</classname>
                            class. The benefit here is polymorphism of
                            <classname>QueryDataProvider</classname>
                            instances and concise code. Using this form also
                            deters
                            developers from using explicit types in their
                            client
                            code which would be easy with the
                            <classname>Dataset</classname>
                            versions.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            This second
                            <classname>Dataset</classname>
                            type takes the specific provider type as a parameter
                            so it will return the
                            <classname>JpaDataProvider</classname>
                            in the
                            <methodname>getProvider</methodname>
                            method. This dataset can be usedful when you want to
                            access provider specific attributes from the
                            dataset
                            that are not available in the more general datasets,
                            at the expense of a lack of polymorphism since you
                            are bound to a
                            <classname>JpaDataProvider</classname>
                            .
                        </para>
                    </listitem>
                    <listitem>
                        Lastly, we have an explicit reference to the
                        <classname>JpaDataProvider</classname>
                        type which is concise and makes it easy to access
                        features on that type, but does not help with
                        interchanging data providers.
                    </listitem>
                </itemizedlist>
            </sect2>
            <sect2>
                <title>Choosing a dataset type</title>
                <para>
                    In general, the rules for choosing a dataset type is fairly
                    simple. In construction code, where you construct and
                    configure
                    the data
                    provider you can refer to it as
                    specifically as you
                    want. However, it is best to refer to it
                    in the client code as
                    far down the hierarchy as possible.
                    Typically, for things like
                    search forms, you might construct
                    a
                    <classname>JpaDataProvider</classname>
                    and set the
                    <methodname>entityManager</methodname>
                    attribute and return it as a
                    <classname>QueryDataset</classname>
                    . In your client code, you can also refer to it as a
                    <classname>QueryDataset</classname>
                    and still gain access to the general features of the query
                    (restrictions, sorting, pagination, and even select/count
                    statements). If you later decide to switch to hibernate or
                    sql,
                    you just need to change the type specific construction
                    code
                    which is logical since you can't change implementation
                    without
                    changing that no matter how abstracted it is.
                </para>
            </sect2>
        </sect1>

        <sect1>
            <title>Extending Datasets for custom providers</title>
            <para>
                When you create a new data provider implementation it is also
                good practice to implement a dataset wrapper for it so your
                users do not have to implement their own, or keep using the
                generic versions. Doing so is very simple, just create a new
                dataset class that extends the
                <classname>Dataset</classname>
                and uses your own custom provider type as the type parameter.
            </para>
            <example>
                <title>Writing datasets for custom providers</title>
                <programlisting role="JAVA" language="java">
<![CDATA[class MyCustomProvider<T> extends AbstractQueryDataProvider<T> {
        ...
        ...                 
  //this is specific to this implementation
  public void setWidgetConnection(WidgetConnection connection) {
    this.connection = conn
  }
}

class MyCustomProviderDataset<T> 
    extends Dataset<T,MyCustomProvider<T>> {
   
   public MyCustomProviderDataset() {
     super();
   }
   
   public MyCustomProviderDataset(MyCustomProvider<T> provider) {
     super(provider);
   }
}]]>
</programlisting>
            </example>
            <para>The dataset name should consist of the provider class name
                with the word dataset appended on the end to make it easy to
                remember. By including this class, it is easier to use datasets
                for custom data providers, especially for custom attributes on
                your new custom provider.</para>
            <example>
                <title>Using your new data provider dataset</title>
                <programlisting role="JAVA" language="java">
<![CDATA[MyCustomProvider<Person> provider = new MyCustomProvider<Person>();
MyCustomProviderDataset<Person> ds = new MyCustomProviderDataset<Person>(provider);
ds.getProvider().setWidgetConnection(ConnectionFactory.createConnection());]]>
</programlisting>
            </example>

            <para>Note that while this provides accessibility to implementation
                specific functions, it does make your code more type specific
                and tightly bound. This has the effect of losing the ability to
                use polymorphism and making your code more tightly coupled to
                specific classes. To avoid this problem, only use more concrete
                class types in factory methods and return a more generalized
                provider or dataset type from the factory to the main
                application. 
            </para>

            <example>
                <title>Using your new data provider dataset</title>
                <programlisting role="JAVA" language="java">
<![CDATA[  QueryProvider<Person> buildProvider() {
    MyCustomProvider<Person> result = new MyCustomProvider<Person>();
    result.setWidgetConnection(xyz);
    return result;
  }

   QueryDataset<Person> buildDataset() {
     MyCustomProvider<Person> provider = buildProvider();
     MyCustomProviderDataset<Person> ds = new MyCustomProviderDataset<Person>();
     ds.getProvider().setWidgetConnection(ConnectionFactory.newConnection);
     return ds;
   }


   ...
   ...
   //assign the dataset using the generic dataset
   QueryProvider<Person> provider = buildProvider();   
   QueryDataset<Person> ds = new QueryDataset<Person>(provider);
   ds.getProvider().addRestriction("p.id = :param",id);
   
   
   //you can even assign custom datasets the the generic query dataset type
   QueryDataset<Person> ds2 = buildDataset(); 
]]>
</programlisting>
            </example>

        </sect1>
    </chapter>
    <chapter>
        <title>Non-Database Providers</title>
        <para>There are a number different non-database sources you can choose
            to fetch data from and usually you have no common way to get that
            data into your application. Spigot provides the ability to fetch
            contents from these sources and transform them to pojos. It does
            this by abstracting the concepts of fetching data to a level that is
            higher than retrieving it from the database. As a result, there are
            a number of different implementations that fetch data without a
            database while letting you benefit from using the same interfaces to
            control the data access.</para>
        <sect1 id="InMemoryDataProvider">
            <title>In-memory based datastores</title>
            <para>
                The simplest form of datastore is one which just keeps the
                objects in memory and the whole set, or subset is returned
                to the
                user when requested. An in-memory data store subclasses
                the
                <classname>InMemoryDataProvider</classname>
                class and implements the abstract method to return the backing
                data. The backing data is the complete list of in-memory results
                that the data provider is paginating. Here is a data provider
                that contains a list of persons
            </para>
            <example>
                <title>In-memory Person data provider.</title>
                <programlisting role="JAVA" language="java">
<![CDATA[public class InMemoryPersonProvider extends InMemoryDataProvider<Person> {

  private List<Person> backingList;
  private static final int PERSON_COUNT = 100;

    @Override
    protected List<Person> fetchBackingData() {
        //generate some random test data
        if (backingList == null) {
            backingList = new ArrayList(PERSON_COUNT);
            for (int i = 0; i < PERSON_COUNT; i++) {
                Person p = new Person(new Long(i + 1), TestDataFactory
                        .getFirstName(), TestDataFactory.getLastName());
                backingList.add(p);
            }
        }
        return backingList;
    }

}]]>
</programlisting>
            </example>
            <para>
                We can now iterate through the data from this provider as though
                it were a database driven provider.
                <classname>InMemorydataProvider</classname>
                result sets can also be sorted by the use of
                <classname>Comparator</classname>
                implementations. Like the database driven providers, the in
                memory providers have an order key map except the key is mapped
                to a comparator instance which is used to order the data in the
                list.
            </para>
            <example>
                <title>In-memory Person data provider.</title>
                <programlisting role="JAVA" language="java">
<![CDATA[public class InMemoryPersonProvider extends InMemoryDataProvider<Person> {

  private List<Person> backingList;
  private static final int PERSON_COUNT = 100;

  private class PersonIdComparator implements Comparator<Person>,Serializable {

        public int compare(Person o1, Person o2) {
            return (int) (o1.getId() - o2.getId());
        }
    }

    private class PersonNameComparator implements Comparator<Person>,
            Serializable {

        public int compare(Person o1, Person o2) {
            int val = o1.getLastName().compareToIgnoreCase(o2.getLastName());
            //if last names match, then try comparing by the first name         
            if (val == 0) {
                val = o1.getFirstName().compareToIgnoreCase(o2.getFirstName());
            }
            return val;
        }
    }

    public InMemoryPersonProvider() {
        //add the order keys by default in the constructor
        getOrderKeyMap().put("id", new PersonIdComparator());
        getOrderKeyMap().put("name", new PersonNameComparator());
    }

    @Override
    protected List<Person> fetchBackingData() {
        //generate some random test data
        if (backingList == null) {
            backingList = new ArrayList(PERSON_COUNT);
            for (int i = 0; i < PERSON_COUNT; i++) {
                Person p = new Person(new Long(i + 1), TestDataFactory
                        .getFirstName(), TestDataFactory.getLastName());
                backingList.add(p);
            }
        }
        return backingList;
    }

}]]>
</programlisting>
            </example>
            <para>
                Again, we can subclass the
                <classname>AbstractObjectDatasetJUnitTest</classname>
                to create new test cases for this class. We can also add in
                additional tests for testing that the ordering is working
                correctly.
            </para>

            <example>
                <title>Testing the InMemoryPersonProvider</title>
                <programlisting role="JAVA" language="java">
<![CDATA[public class InMemoryPersonProviderTest
    extends AbstractObjectDatasetJUnitTest<Person> {

    @Override
    public ObjectDataset<Person> buildObjectDataset() {
        InMemoryPersonProvider provider = new InMemoryPersonProvider();
        return new Dataset<Person>(provider);
    }

    @Override
    public int getDataRowCount() {
        return 100;
    }

    public void testIdOrdering() {
        ObjectDataset<Person> ds = buildObjectDataset();
        ds.setOrderKey("id");
        ds.setOrderAscending(false);
        ds.setMaxRows(10);
        //check descending
        Long id = null;

        for (Person p : ds) {
            if (id != null) {
                assertTrue("Next Id is not less than the last",p.getId() < id);
            }
            id = p.getId();
        }


        //now reverse the ordering
        ds.setOrderAscending(true);
        id = null;
        for (Person p : ds) {
            if (id != null) {
                assertTrue("Next Id is not greater than the last",p.getId() > id);
            }
            id = p.getId();
        }

    }
}]]>
</programlisting>
            </example>
            <para>
                In this test case, we toggle the ordering to ensure that the
                ordering is working as we switch from one order to the next. One
                caveat with ordering in memory providers is that the ordering
                takes place on the backing data list in the data provider.
                Therefore, you can't directly have multiple paginators that
                fetch independent views of the data since they would all have to
                share the same sort order. You could do this if there was no
                ordering or they used the same order. However to get around this
                you could use an
                <classname>InMemoryAdapterProvider</classname>
                .
            </para>
        </sect1>
        <sect1 id="InMemoryAdapterProvider">
            <title>
                <classname>InMemoryAdapterProvider</classname>
            </title>
            <para>
                The
                <classname>InMemoryAdapterProvider</classname>
                wraps an existing
                <classname>DataProvider</classname>
                (any kind, not just the in-memory kind) from which it sucks up
                all the data and puts it in its own in-memory list. This can be
                used to either make a data provider a fast in-memory provider,
                or create an independent view of an in-memory dataset with
                indendent sorting.
            </para>
            <para>
                While the
                <classname>InMemoryAdapterProvider</classname>
                keeps a separate list of the data elements, it does not keep its
                own copy of the actual data which is shared with the original
                provider. This lets you use a single copy of the all data, but
                lets you have independent lists of the data. Obviously, care
                must be taken when using this on a database since it will load
                all the data from the source data provider into memory.
            </para>
            <example>
                <title>Multiple views using an in-memory adapter.</title>
                <programlisting role="JAVA" language="java">
<![CDATA[  InMemoryPersonProvider provider = new InMemoryPersonProvider();
  InMemoryAdapterProvider<Person> providerAdapter =
    new InMemoryAdapterProvider<Person>(provider);

  ObjectDataset<Person> ds = new Dataset<Person>(provider);
  ObjectDataset<Person> ds2 = new Dataset<Person>(providerAdapter);

  //shared data, independent ordering and paging
  ds.setOrderKey("name");
  ds2.setOrderKey("id");]]>
</programlisting>
            </example>
            <para>
                The
                <classname>InMemoryAdapterProvider</classname>
                will automatically pick up the order key comparators if it wraps
                an
                <classname>InMemoryDataProvider</classname>
                which it does in this case.
            </para>
        </sect1>
        <sect1>
            <title>
                <classname>IntegerDataProvider</classname>
                revisited
            </title>
            <para>
                Here is our
                <classname>IntegerDataProvider</classname>
                reimplemented using the in-memory data provider. All we need to
                do is override the method to return the backing data and return
                our list of integers from 1 to 100.
            </para>
            <example>
                <title>in-memory implementation of our Integer provider.</title>
                <programlisting role="JAVA" language="java">
<![CDATA[public class InMemoryIntegerProvider
    extends InMemoryDataProvider<Integer> implements Serializable {

    @Override
    protected List<Integer> fetchBackingData() {
        List<Integer> result = new ArrayList<Integer>();
        for (int i = 1;i <=100;i++) {
            result.add(i);
        }
        return result;
    }

}]]>
</programlisting>
            </example>
            <para>
                We can also easily test this using our
                <classname>IntegerDataProviderTest</classname>
                class that we used to test the integer data provider last time
                by subclassing it and overriding the
                <methodname>buildObjectDataset</methodname>
                method. This time we return an instance of our in-memory Integer
                data provider.
            </para>
            <example>
                <title>Testing our in-memory Integer data provider.</title>
                <programlisting role="JAVA" language="java">
<![CDATA[
public class InMemoryIntegerProviderTest extends IntegerDataProviderTest {

    @Override
    public ObjectDataset<Integer> buildObjectDataset() {
        DataProvider<Integer> provider = new InMemoryIntegerProvider();
        return new Dataset<Integer>(provider);

    }
}]]>
</programlisting>
            </example>

            <para>
                In our previous implementation of the Integer data provider we
                neglected to include sorting, so this time we'll add sorting
                into this implementation. Since our integer in-memory data
                provider only has one comparator to order by (for comparing two
                integers), we could just override the
                <methodname>translateOrderKey</methodname>
                method to return the single comparator in our dataset. The saves
                us from making the user assign an order key value, and it will
                always be sorted by this comparator.
            </para>
            <example>
                <title>Sorting the Integer data provider.</title>
                <programlisting role="JAVA" language="java">
<![CDATA[public class InMemoryIntegerProvider extends InMemoryDataProvider<Integer>
    implements Serializable {

  private transient Comparator<Integer> comparator = new Comparator<Integer>() {
    public int compare(Integer o1, Integer o2) {
      return o1-o2;
    }
};

  @Override
  protected List<Integer> fetchBackingData() {
    List<Integer> result = new ArrayList<Integer>();
    for (int i = 1;i <=100;i++) {
      result.add(i);
    }
    return result;
  }

  @Override
  protected Comparator<Integer> translateOrderKey(String key) {
    return comparator;
  }
}]]>
</programlisting>
            </example>
            <para>Note also that in this case, the comparator field is marked
                transient
                since it is not serializable.
            </para>
        </sect1>
        <sect1>
            <title>File Based Data Providers</title>
            <para>
                One common need is to base a set of data of one or more files
                which can be either text based, comma delimited, xml or some
                proprietary format. Spigot again provides the same interface to
                access these data sources. At the root of file based data
                providers, we have the
                <classname>AbstractFileBasedProvider</classname>
                which takes a filename in its constructor and creates the
                <classname>File</classname>
                instance. This is subclassed into different implementations.
            </para>
            <sect2>
                <title>TextFileProvider</title>
                <para>
                    The
                    <classname>TextFileProvider</classname>
                    is the base class for data providers using text files as the
                    data source. It treats each line in the file as a row of
                    data and calls the abstract method
                    <methodname>createObjectFromLine(String line)</methodname>
                    to generate an instance of the object data for each row in
                    the file. This is further extended in the
                    <classname>CommandDelimitedProvider</classname>
                    which assumes that each row of text is a row of comma
                    delimited data. For each row of data, the provider splits up
                    the data elements and passed them as a string array to the
                    abstract method
                    <methodname>createObjectFromColumns(String[] columns)
                    </methodname>
                    Subclasses need to implement this method to return the
                    specific type of entity that this data provider returns.
                </para>
            </sect2>
        </sect1>

    </chapter>
    <chapter>
        <title>Odds and Ends</title>

        <para>This sections covers any additional info not included anywhere
            else.
  </para>
        <sect1 id="IndexedDataProviderCache">
            <title>IndexedDataProviderCache</title>
            <para>
                The
                <classname>IndexedDataProviderCache</classname>
                provides random access to provider data with look ahead caching
                to optimize querying and take advantage of data coherence. The
                best example of this is in the swing table which is included in
                one of the examples. A swing table model knows the number of
                rows of data that exist (which could be thousands or millions)
                and lets the user scroll across the whole dataset. This means
                that the user can select any record from the available dataset
                at any point in time. In this event, it would be fetched from
                the data provider and returned to the user. However, the user
                will probably end up fetching the next x number of objects from
                the dataset as the next x number of rows in the table are
                displayed. For this reason, the cache not only fetches the
                requested row, but the next n number of rows where n is the
                batch size defined by an attribute on the cache. The
                <classname>IndexedDataProviderCache</classname>
                keeps hold of these items since they may well be reused when the
                table is repainted or the user starts to scroll backwards or
                forwards a few records at a time. This cache is limited in size,
                and records will start to be ejected on a least recently used
                basis. The
                <classname>IndexedDataProviderCache</classname>
                can be used to randomly browse thousands of records with no
                startup time and efficient memory use since it doesn't read all
                the data in at once. (The delay at the start is due to the
                creation of the database, not the loading of all the data).
            </para>
        </sect1>
        <sect1>
            <title>Don't call record count</title>
            <para>
                You should not avoid calling
                <methodname>fetchRecordCount</methodname>
                from within the data provider. The most likely place you will
                call it is to determine whether there are more results to be
                returned. This can be an expensive call to count all records or
                rows of data from the source that should be avoided if possible.
                In the database data provider included, we fetch an extra row to
                see if there are more results after the set of rows we want.
                This extra row is then taken off the final results that are
                returned to the user.
            </para>
        </sect1>
        <sect1>
            <title>Seam Usage</title>
            <para>
                With Spigot you can subclass either a
                <classname>SeamJPaQueryDataset</classname>
                or a
                <classname>SeamJpaNativeDataset</classname>
                so you can use either a Ejbql or Native query for fetching data.
                Also, there is an adapter class that can be used instead which
                adds on the additional methods needed to make the class
                compatible with
                <classname>EntityQuery</classname>
                based classes.
            </para>
        </sect1>

    </chapter>
</book>
