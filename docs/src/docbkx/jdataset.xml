<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<book>
	<title>JDataset Reference Guide</title>
	<titleabbrev>JDataset Ref</titleabbrev>
	<bookinfo>
		<author>
			<personname>
				<firstname>Andy</firstname>
				<surname>Gibson</surname>
			</personname>
		</author>
		<copyright>
			<year>2009</year>
			<holder>Andy Gibson</holder>
		</copyright>
	</bookinfo>
	<chapter id="Introduction">
		<title>Introduction</title>
		<para>
			The purpose behind this framework is to let developers access
			diverse
			sources of data in an easy and consistent
			manner. It also
			aims to augment the
			functionalities of existing data access
			mechanisms such as JDBC, Hibernate and
			JPA
			in a reusable manner.
		</para>
		<sect1>
			<title>The Itch</title>
			<para>
				When starting a new data driven application you typically need
				some
				mechanism to query data with the following
				capabilities:
		</para>
			<itemizedlist>
				<listitem>
					<para>Pagination of large datasets</para>
				</listitem>
				<listitem>
					<para>Dynamic Ordering (for clickable columns)</para>
				</listitem>
				<listitem>
					<para>Lazy Loading of data</para>
				</listitem>
				<listitem>
					<para>Optional restrictions in the query for when parameter values
						are
						missing</para>
				</listitem>
				<listitem>
					<para>The ability to apply a common front end to the back end query
						mechanism so you can reuse both pieces to
						implement forms in
						minutes.</para>
				</listitem>
			</itemizedlist>
			<para>
				As a long time Seam user, Seam provides most of this with the
				<classname>EntityQuery</classname>
				that can be used to run queries using JPA but it isn't perfect. I
				extended
				the Seam
				<classname>EntityQuery</classname>
				and
				<ulink
					url="http://www.andygibson.net/blog/index.php/2008/10/02/codeless-ajax-ordered-and-paginated-tables-in-seam/">blogged about it </ulink>
				and it still remains a popular article today and one I get most
				emails about
				when people are looking for JSF and
				pagination.
				However, this stil has
				problems since it only works in Seam projects
				but the same functionality is
				needed
				in Wicket, Spring, JSP and even
				Swing and console apps. Other
				frameworks such as Wicket provided an
				interface for
				handling ordered paginated
				datasets, but the
				implementation was
				usually up to the user as this was beyond
				the
				scope of
				Wicket.
			</para>

			<para>The other source of inspiration is from Borland Delphi which
				worked on
				the idea that a common data access
				interface meant that
				data driven components
				could access data without considering where
				it came from. A standard query
				interface means we can create a
				reusable front end. Third party Delphi
				component developers could
				create data access
				components that would work with
				any kind of data
				source, from Oracle, MySQL and MS Access to XML or file
				based
				datasets as long as there was a dataset implementation for it. When
				developing in Java, you typically have to code
				against a common but
				more
				precise back end such as a JDBC query and write new interfaces
				for different
				view
				technologies.
			</para>
			<para>It seems that all these frameworks recognized the need to
				access data in
				a uniform way, but it was beyond the
				scope of the
				frameworks to provide it,
				and the scope of what they did provide was
				usually limited to their own
				framework. Without a uniform data
				access mechanism developers have to write
				and re-write their front
				and back ends
				every time they start a new project or
				want to re-use
				some existing code from a different view technology.
			</para>
			<figure>
				<title>Projects without using JDatasets</title>
				<mediaobject>
					<imageobject role="fo">
						<imagedata align="center" fileref="../img/app_without_jds.png"
							scalefit="1" />
					</imageobject>
					<imageobject role="html">
						<imagedata align="center" fileref="../img/app_without_jds.png" />
					</imageobject>
				</mediaobject>
			</figure>


		</sect1>

		<sect1>
			<title>The Solution</title>
			<para>So, I scratched my own itch and created this project that
				defines a
				common API for querying diverse data sources
				with
				pagination and optionally
				with ordering, restrictions and
				parameters. This lets us write common view
				code that
				can interface
				with queries that are interchangeable. 
			</para>
			<figure>
				<title>Projects using JDatasets</title>
				<mediaobject>
					<imageobject role="fo">
						<imagedata align="center" fileref="../img/app_with_jds.png"
							scalefit="1" />
					</imageobject>
					<imageobject role="html">
						<imagedata align="center" fileref="../img/app_with_jds.png" />
					</imageobject>
				</mediaobject>
			</figure>
			<sect2>
				<title>Architecture</title>
				<para>
					JQA is organized into two main interfaces called
					<classname>Paginator</classname>
					and
					<classname>DataProvider</classname>
					. The
					<classname>Paginator</classname>
					holds the state about our dataset such as the order information,
					the page
					size and the current page. The
					<classname>DataProvider</classname>
					interface defines two simple methods which are used to fetch the
					total
					number of rows in the dataset, and a (sub)set
					of the items in
					the
					dataset.
				</para>
				<example>
					<title>
						The
						<classname>DataProvider</classname>
						interface
					</title>
					<programlisting role="JAVA">
<![CDATA[
public interface DataProvider<T> {
	Integer fetchResultCount();
	List<T> fetchResults(Paginator paginator);
}
]]>
					</programlisting>
				</example>
				<para>
					When we fetch the results, we pass in the paginator so the
					<classname>DataProvider</classname>
					implementation knows which rows to return.
				</para>
			</sect2>
			<sect2>
				<title>Benefits of Java Query Adapters</title>
				<para>
					Even if you still plan on using a single data access mechanism
					(i.e.
					Hibernate or JPA) there are still
					advantages to using Java
					Query
					Adapters.
				</para>

				<sect3>
					<title>Interchangable query mechanisms</title>
					<para>
						Most projects only plan on using one data access mechanism
						but by
						coding to the JQA API, you can easily switch
						implementation
						later. You might
						move from JPA to hibernate or even to plain JDBC
						queries and your code that
						uses
						these queries, including
						parameterized
						queries, will remain the same.
					</para>
					<para>If you later need to introduce some new kind of data
						store
						into the
						project, you can do so while using your
						existing view code
						to paginate and
						order the data. Even if you can
						never imagine
						switching data access
						mechanisms or
						having to access
						diverse data
						stores, you may want to just
						switch the query here
						and there from a
						pure ORM type query
						to a JDBC SQL
						query but still
						want to interface
						with the data the same way you do with
						your
						other queries.
					</para>
				</sect3>

				<sect3>
					<title>Easy Querying</title>
					<para>JQA makes it easier to query for the data
						you need. It
						features
						flexible parameter definition by setting the
						value
						manually, using EL
						expressions, extracting the values using
						reflection or your own custom
						parameter resolver.
						Parameters that
						don't have a value assigned can
						optionally be left out of the
						query which can be useful when you are
						writing search forms where
						the user may leave out search criteria and you
						don't want it
						included in the query. Doing
						this manually can lead to
						problematic
						code that is hard to read, test and maintain.
					</para>
					<example>
						<title>
							Coding search queries the hard way.
                    </title>
						<programlisting role="JAVA">
<![CDATA[
if (searchCriteria.id != null  
  && searchCriteria.id.length() != 0) {
    if (sql.length()!= null) {
      sql = sql + " AND ";
    }
    sql= sql+ "p.id = :id";
    paramsMap("id",searchCriteria.id);
}

if (searchCriteria.firstName != null  
  && searchCriteria.firstName.length() != 0) {
    if (sql.length()!= null) {
      sql = sql + " AND ";
    }
    sql= sql+ "p.firstName = :firstName";
    paramsMap("firstName",searchCriteria.firstName);
}

if (searchCriteria.lastName != null  
  && searchCriteria.lastName.length() != 0) {
    if (sql.length()!= null) {
      sql = sql + " AND ";
    }
    sql= sql+ "p.lastName = :lastName";
    paramsMap("lastName",searchCriteria.lastName);
}

qry = createQuery(sql);
for (String key : paramsMap.keySet) {
  qry.setParameter(key,paramsMap.get(key))
}

List<Person> results = qry.resultList();
]]>
					</programlisting>

					</example>
					<para>With JQA, you can define the query once, specify
						how the
						parameters are
						resolved and the query
						will take care of
						generating
						the right request so that
						the only
						restrictions included in the
						query are ones with parameter values
						assigned.</para>
					<example>
						<title>
							Coding search queries the easy way.
                    </title>
						<programlisting role="XML">
<![CDATA[
qry.addRestriction("p.id = :id");
qry.addRestriction("p.firstName = :firstName");
qry.addRestriction("p.lastName = :lastName");
ParameterResolver resolver = 
  new ReflectionParameterResolver(searchCriteria));
qry.addParameterResolver(resolver);
List<Person> results = qry.resultList();]]>
					</programlisting>
					</example>
				</sect3>


				<sect3>
					<title>Flexible and Secure Ordering Abstraction</title>
					<para>JQA lets you order your data based on order key values as
						opposed to
						explicit table column values which could
						be prone to SQL
						injection attacks.
						By using an orderKey value which is translated
						server side into a
						query
						level
						representation, you can control what
						values are used
						for setting the
						order of the dataset ensuring no
						harmful
						SQL is
						inserted into your query.
					</para>
					<para>There are even provisions for assisting sorting in non-SQL
						based
						queries using comparators.</para>
				</sect3>
				<sect3>
					<title>Convert anything into a dataset</title>
					<para>At the heart of JQA is a simple API which allows you to turn
						anything
						into a dataset that can be accessed and
						paginated from
						reusable view code.
						This can range from custom datasources or
						third party applications, to
						text, csv
						or binary file sources or
						even just an in-memory list of objects.
					</para>
				</sect3>
			</sect2>
		</sect1>
	</chapter>
	<chapter>
		<title>Architecture</title>
		<para>
			This section covers the architecture of the framework and how
			they all
			relate to each other.</para>
		<sect1>
			<title>Main API</title>
			<para>
				The main API consists of the
				<classname>Paginator</classname>
				and
				<classname>DataProvider</classname>
				interfaces. The Paginator is like a bookmark for a dataset and holds
				the
				current record, page size and ordering
				information as well as
				flags indicating
				whether there is a previous or next page available.
				Inversely, the
				<classname>DataProvider</classname>
				is the stateless part of the equation. It provides the data to the
				end user
				when requested based on the state of the
				paginator passed
				in.
			</para>
			<example>
				<title>Fetching data from a provider</title>
				<programlisting>
<![CDATA[				
  DataProvider prov = new CustomDataProvider();
  Paginator paginator = new DefaultPaginator();
  List<ResultClass> results = prov.fetchResults(paginator);
  Integer count = prov.getResultCount();  
]]>  
				</programlisting>
			</example>
			<para>
				This is a simple example where we create an instance of our custom provider
				that knows how
				to fetch the data. We create an instance of a
				<classname>Paginator</classname>
				and when we fetch the results we pass that in to the datasource to
				tell the
				provider which set of data to return. In
				this case, we
				returned all the data
				but by setting properties on the paginator we
				can tell the provider just to
				return
				a subset.
			</para>
			<example>
				<title>Limiting the data fetched from a data provider</title>
				<programlisting>
<![CDATA[				
  DataProvider prov = new CustomDataProvider();
  Paginator paginator = new DefaultPaginator();
  paginator.setMaxRows(10);
  paginator.setFirstResult(35);
  List<ResultClass> results = prov.fetchResults(paginator);
  Integer count = prov.fetchResultCount();
    
]]>  
				</programlisting>
			</example>
			<para>
				Here we set the maximum number of rows to return to 10 and we want the first
				result to start at item number 35. The implementation of the
				<classname>CustomProvider</classname>
				is responsible for returning the correct subset of data to the caller. It is
				also responsible for setting the
				<code>nextAvailable</code>
				flag on the paginator. This keeps track of whether there are more results
				available or not.
			</para>
			<para>
				If you were to call
				<methodname>fetchResults</methodname>
				a second time, the provider would go off and re-fetch the data executing
				whatever process it does to fetch the data. It does not cache the data in
				anyway and should be implemented statelessly such that one call to the
				dataset is independent to any other calls to the dataset.
			</para>
			<para>
				The third part of the interface is an
				<classname>ObjectDataset</classname>
				which combines both the provider and paginator information into one
				class and
				can be used to manage the fetched data.
				This component
				should be considered
				stateful as it holds on to the results and
				caches them. This piece is very
				similar
				to the
				<classname>EntityQuery</classname>
				component in Seam. It also lets you iterate over the dataset easily and
				doing so
				will also take pagination into account.
			</para>
			<example>
				<title>
					Using an
					<classname>ObjectDataset</classname>
				</title>
				<programlisting>
<![CDATA[				
  DataProvider provider = new CustomDataProvider();
  Dataset<SomeClass> dataset = new Dataset(provider);
  dataset.setMaxRows(10);
  dataset.setFirstResult(35);
  List<ResultClass> results = dataset.getResults();
  for (SomeClass item : dataset) {
    ...some code...
  }
]]>  
				</programlisting>
			</example>
			<para>
				The
				<classname>ObjectDataset</classname>
				incorporates its own
				<classname>Paginator</classname>
				and works on the data provider passed in to the constructor.
			</para>
		</sect1>
	</chapter>
	<chapter>
		<title>Using Database Driven Providers</title>
		<para>
			While JQA offers a way to access many different types of data stores, in most
			cases, you will want to fetch data from a database. JQA comes with data
			providers for fetching data using JPA, Hibernate or just plain SQL via JDBC.
			These different providers are based off and implement the
			<classname>QueryDataProvider</classname>
			. This interface adds features such as ordering, restrictions and parameters
			for flexible querying. Note that since they implement the same interface,
			they can be interchanges with very little code changes if any.
		</para>
		<sect1>
			<title>Simple Fetches</title>
			<para>
				Let's start by considering some simple cases of fetching data using a
				data
				driven query.
				</para>
			<example>
				<title>
					Fetching data from a database using JPA					
				</title>
				<programlisting>
<![CDATA[

  QueryProvider<Person> provider = new JpaDataProvider<Person>(em);
  QueryDataset<Person> dataset = new QueryDataset<Person>(provider);
  dataset.init(Person.class, "p");
  List<Person> results = dataset.getResultList();
  for (Person p : results) {
    System.out.println(p.getName());
  }
]]>  
				</programlisting>
			</example>
		</sect1>
		<sect1>
			<title>Restricting Results</title>
			<para>
				We can add restrictions to the query so we only return a set of rows
				that we
				want. In this case, we want to return a specific person.
		</para>

			<example>
				<title>
					Restricting the data fetched					
				</title>
				<programlisting>
<![CDATA[  
  QueryDataProvider<Person> provider = createPersonProvider();
  provider.addRestriction("p.id = 4");  
]]>  
				</programlisting>
			</example>


			<para>It is often more convenient to specify restrictions using parameters
				and
				JQA has a number of different mechanisms with which to specify
				parameterized
				restrictions. First we'll look at the straightforward adding of
				a
				parameter.
		</para>

			<example>
				<title>
					Parameterized restrictions					
				</title>
				<programlisting>
<![CDATA[  
  QueryDataProvider<Person> provider = createPersonProvider();
  provider.addRestriction("p.id = :param",4);
  provider.addRestriction("or p.id = :param",88);
]]>  
				</programlisting>
			</example>
			<para>
				In many cases, we don't want to include restrictions where the value we
				are
				comparing is
				<code>null</code>
				, such as search forms where the user has left values
				blank. In these cases,
				any restriction with null parameter should not be included.
			</para>
			<example>
				<title>
					Parameterized restrictions					
				</title>
				<programlisting>
<![CDATA[  
  QueryDataProvider<Person> provider = createPersonProvider();
  provider.addRestriction("p.firstName = :param",searchCriteria.firstName);
  provider.addRestriction("or p.lastName = :param",searchCriteria.lastName);
]]>  
				</programlisting>
			</example>
			<para>
				These are really just helper methods so you don't have to do your own "
				<code>if value != null then add parameter</code>
				" code for each line, although it is certainly possible that you can do
				that
				in certain cases. However, many times you want to evaluate one value to
				check
				if is null but use another value for the parameter. We have a method
				for
				that
				too.
			</para>
			<example>
				<title>
					Parameterized restrictions					
				</title>
				<programlisting>
<![CDATA[  
  QueryDataProvider<Person> provider = createPersonProvider();
  provider.addRestriction("p.firstName like :param",searchCriteria.firstName,searchCriteria.firstName+"%");
  provider.addRestriction("or p.lastName like :param",searchCriteria.lastName,searchCriteria.lastName+"%");
]]>  
				</programlisting>
			</example>
			<para>
				What we do there is check whether the first/last name value is null and
				if
				so,
				we do nothing, but otherwise we add the restriction and for the
				parameter, we
				use the value with the wildcard appended. Also note that we use
				the
				<code>OR</code>
				expression in the second restriction which lets us find people where the
				first or second restrictions apply. If there is no logical operator at the
				start of the restriction then by default an
				<code>AND</code>
				expression is prefixed onto it.
			</para>
			<para>This may seem a fairly broad set of ways to parameterize the your
				queries, but it is only scratching the surface. </para>
		</sect1>
		<sect1>
			<title>Parameter Resolvers</title>
			<para>
				The
				<code>ParameterResolver</code>
				interface can be used to attach code at run time that will resolve
				parameters. When the query is executed the parameters are evaluated as the
				query is built so any restrictions with null parameters can be excluded. We
				can attach parameter resolvers to the provider so it will be used when the
				provider tries to resolve the parameter for a restriction. This mechanism
				allows us to attach an EL parameter resolver for environments where EL is in
				use (such as JSF, or Seam applications).
			</para>
			<para>It also lets offers us different mechanisms for resolving values such
				as using reflection onto a an object.</para>
			<example>
				<title>
					Parameter Resolving with Reflection					
				</title>
				<programlisting>
<![CDATA[  
  QueryDataProvider<Person> provider = createPersonProvider();
  provider.addRestriction("p.firstName like :firstName");
  provider.addRestriction("or p.lastName like :lastName");
  provider.addParameterResolver(new ReflectionParameterResolver(searchCriteria));
]]>  
				</programlisting>
			</example>
			<para>We can also bake the parameter resolver into the object itself by
				making it implement the parameter resolver interface.</para>
			<example>
				<title>
					Built in parameter resolution					
				</title>
				<programlisting>
<![CDATA[  
public class SearchCriteria implements ParameterResolver {

    //return values with wildcards
	boolean resolveParameter(ParameterizedDataProvider<? extends Object> dataset,
			Parameter parameter) {
			if ("firstName".equals(parameter.getName())) {			  
			  return firstName == null ? null : firstName+"%";
			}
			if ("lastName".equals(parameter.getName())) {			  
			  return lastName == null ? null : lastName+"%";
			}
			return null;
    }

	boolean acceptParameter(String name) {
	  return name.startsWith(":");
	}

}

...
...
...

  QueryDataProvider<Person> provider = createPersonProvider();
  provider.addRestriction("p.firstName = :firstName");
  provider.addRestriction("or p.lastName = :lastName");
  provider.addParameterResolver(searchCriteria);
]]>  
				</programlisting>
			</example>
			<para>
				The Seam data provider classes use an EL based parameter resolver
				by default
				so you can simple use it the same way you would with an
				<classname>EntityQuery</classname>
				.
			</para>

			<example>
				<title>
					Using the Seam data provider 					
				</title>
				<programlisting>
<![CDATA[  
@Name("myPostsQuery")
pulic class MyPostsQueryBean extends SeamJpaQueryDataset{
  public MyPostsQueryBean() {
    setSelectStatement("select p from Posts p left join fetch p.comments");
    setSelectStatement("select count(p) from Posts p");    
    addRestriction("p.author.id = #{loggedInUser.id}");
  }
}
]]>  
				</programlisting>
			</example>
			<para>
				On the subject of Seam, with JQA you can subclass either a
				<classname>SeamJPaQueryDataset</classname>
				or a
				<classname>SeamJpaNativeDataset</classname>
				so you can use with a Ejbql or Native query for fetching data. Also, there
				is an adapter class that can be used instead which adds on the additional
				methods needed to make the class compatible with
				<classname>EntityQuery</classname>
				based classes.
			</para>
		</sect1>
		<sect1>
			<title>Order in the house</title>
			<para>JQA also features key based ordering so rather than specify ordering as
				a set of fields on the dataset, you can specify ordering using a key that
				maps to one or more fields.</para>
			<example>
				<title>
					Ordering on the data
				</title>
				<programlisting>
<![CDATA[  
  QueryDataProvider<Person> provider = createPersonProvider();  
  provider.addRestriction("p.lastName = 'SMITH'");
  provider.getOrderKeyMap().put("name","p.lastName,p.firstName");
  provider.getOrderKeyMap().put("age","p.dateOfBirth");
  provider.getOrderKeyMap().put("id","p.id");
  //now set the order
  Paginator paginator = new DefaultPaginator();
  paginator.setOrderKey("name");  //order by the persons name
  paginator.setOrderAscending(false);
  
  List<Person> orderedList = provider.fetchResults(paginator):
]]>  
				</programlisting>
			</example>
			<para>
				Note that in this example, the order key map has two fields, last and
				first
				name to sort on. If this key is used, then both these fields will be
				used to
				order both ascending and descending. The order information consists of the
				key value which indicates which key to use and whether it is meant to be
				ascending or descending. Both of these attributes are on the
				<classname>Paginator</classname>
				interface and are read from it when
				<methodname>fetchResults</methodname>
				is called on the provider.
			</para>
		</sect1>
		<sect1>
			<title>Polymorphism</title>
			<para>
				One of the best features here is that in order to switch from Hibernate to
				JPA, or another JPA implementation, all we need to change is our
				<methodname>createPersonProvider()</methodname>
				method. Following good principles, we have been coding to an interface and
				not an actual class type so we are not locked in to using a concrete class,
				but any class that implements the
				<classname>QueryDataProvider</classname>
				interface. Currently, there are
				<classname>QueryDataProvider</classname>
				implementations for SQL/JDBC, native Hibernate and JPA. The JPA versions
				include both Ejbql and Native querying as do the Seam extensions for the JPA
				providers.
			</para>
			<para>
				You could easily return a hibernate data provider from the
				<methodname>createPersonProvider</methodname>
				without having to change any code since the mappings will be the same.
			</para>
		</sect1>
		<sect1>
			<title>Mapping SQL to Objects</title>
			<para>One problem so far is that our data providers always deal with objects
				while our sql based datasets are begin defined as a group of rows of values.
				We still need some way to convert that raw data into an object that can be
				returned in our results.</para>
			<para>
				This can be done in one of two ways but both involve a
				<classname>java.sql.ResultSet</classname>
				and building an instance of our model objects from the current row of data.
			</para>
			<para>
				The first method is to subclass the
				<classname>AbstractJdbcDataProvider</classname>
				and override the
				<methodname>createObjectFromResultSet</methodname>
				method.
			</para>
			<example>
				<title>
					Implementing the SQL to Object mapping
				</title>
				<programlisting>
<![CDATA[
public class PersonDataProvider extends AbstractJdbcDataprovider<Person> {
  public T createObjectFromResultSet(ResultSet resultSet) throws SQLException {
    return new Person(resultSet.getLong(1), resultSet.getString(2),
	    resultSet.getString(3));
  }
}  
]]>  
				</programlisting>
			</example>
			
		</sect1>

	</chapter>
	<chapter>
		<title>Introducing the data provider</title>
		<para>This chapter looks at creating a simple data provider, testing
			it and
			seeing the different ways we can access the
			data in it.</para>
		<sect1>
			<title>
				Our first
				<classname>DataProvider</classname>
			</title>
			<para>
				Let us start by seeing how the different parts and pieces connect by
				creating a new provider that
				lists the
				numbers
				from 1 to 100 and
				we
				will access
				it in different ways. We'll start
				by
				writing our data
				provider
				that implements
				the
				<classname>DataProvider&lt;Integer&gt;</classname>
				interface.
			</para>
			<example>
				<title>
					<code>IntegerDataProvider.java</code>
				</title>
				<programlisting role="JAVA">
<![CDATA[
public class IntegerDataProvider implements DataProvider<Integer>,Serializable {

	public Integer fetchResultCount() {
		return 100;
	}

	public List<Integer> fetchResults(Paginator paginator) {
		
		int start = paginator.getFirstResult();
		
		int end = paginator.includeAllResults() ? 100 : 
		  Math.min(100, start+paginator.getMaxRows().intValue()-1);
		
		List<Integer> results = new ArrayList<Integer>();
		System.out.println("Generating results from "+start+" to "+end);
		while (start <= end) {
			results.add(start++);			
		}
		paginator.setNextAvailable(end < 100);
		return results;
	}
}
]]>
			</programlisting>
			</example>
			<para>
				The
				<methodname>fetchResultCount()</methodname>
				method returns a constant value of 100 in this case because we are
				dealing
				with a fixed range of integers. Typically
				though, this will
				return the number
				of items in the complete dataset and is used to
				determine the number pages
				available.
			</para>
			<para>
				The
				<methodname>fetchResults</methodname>
				methods takes a paginator and generates the list of integers to
				return to the
				user. The list is based on two things,
				the
				<code>firstResult</code>
				value that determines which page we are on and therefore where to
				start
				counting from, and the
				<code>maxRows</code>
				value that determines how many results to return. If
				<code>maxRows</code>
				is set to null then we are returning all rows, and we have the
				utility method
				<methodname>includeAllResults</methodname>
				to make it easier to check this. Once we have determined the start
				and end
				points to count from and to, we build the
				list of results,
				and before
				returning it, we set the flag for indicating whether
				there
				are more results
				available. This
				is the responsibility of the
				data
				provider because only it
				knows whethere there are more results.
			</para>
			<para>Next, we'll create a client for this provider as a simple class
				that
				just fetches the results and lists them.
			</para>
			<example>
				<title>
					<code>IntegerDataProvider.java</code>
				</title>
				<programlisting role="JAVA">
<![CDATA[
public class Main {

	public static void main(String[] args) {
		Paginator paginator = new DefaultPaginator(10);
		DataProvider<Integer> provider = new IntegerDataProvider();		

		List<Integer> results = provider.fetchResults(paginator);
		showResults(results);
	}

	public static void showResults(List<Integer> results) {
		System.out.println("Result Size = " + results.size());

		for (Integer i : results) {
			System.out.println("Value = " + i);
		}
	}
}	
]]>
</programlisting>
			</example>

			<para>
				In the
				<methodname>main</methodname>
				method, we create a new
				<classname>DefaultPaginator</classname>
				instance that implements the
				<classname>Paginator</classname>
				interface. We pass our initial page size into the constructor so we
				will
				start by returning 10 rows at a time. We
				then create an
				instance
				of our data
				provider, and call the
				<methodname>fetchResults</methodname>
				method to return the first page of results. We then pass the results
				to the
				<methodname>showResults</methodname>
				method which just displays the number of results. If we run this, we
				get the
				expected list of numbers from 0 to 9
				with a page size of 10.
			</para>
			<example>
				<title>
					Execution Results
				</title>
				<programlisting role="JAVA">
<![CDATA[
Generating results from 0 to 9
Result Size = 10
Value = 0
Value = 1
Value = 2
Value = 3
Value = 4
Value = 5
Value = 6
Value = 7
Value = 8
Value = 9
]]>
</programlisting>
			</example>
			<para>
				So everthing looks fine, this is the result we expected so we
				must
				have
				a
				working dataset right? Well not so fast.
				Let's create a
				test case
				for
				it first.
				Since we are working with well defined
				interfaces we can
				define a test case
				that
				tests the interface and
				make
				sure our
				implementation is meeting the
				contract defined by the
				interface.
			</para>
		</sect1>
		<sect1>
			<title>
				Testing our
				<classname>DataProvider</classname>
			</title>
			<para>
				Create a new class (in the test packages if applicable) and create
				it
				as a
				subclass of
				<classname>package
					org.jdataset.testing.junit.AbstractObjectDatasetJUnitTest
				</classname>
				. This class defines two methods which needs to be implemented in
				subclasses. The
				<methodname>getDataRowCount()</methodname>
				returns the number of rows expected in the dataset and the
				<methodname>buildObjectDataset</methodname>
				method returns an instance of an
				<classname>ObjectDataset</classname>
				. An
				<classname>ObjectDataset</classname>
				is a class that combines a
				<classname>Paginator</classname>
				and a
				<classname>DataProvider</classname>
				implementation in one class for convenience. We can easily create
				one
				by
				creating an instance of a
				<classname>org.jdataset.impl.Dataset</classname>
				and pass it an instance of our
				<classname>IntegerDataProvider</classname>
				which the dataset will use to obtain data.
				.
			</para>

			<example>
				<title>
					<code>IntegerDataProvider.java</code>
				</title>
				<programlisting role="JAVA">
<![CDATA[
public class IntegerDataProviderTest extends 
  AbstractObjectDatasetJUnitTest<Integer> {

	@Override
	public ObjectDataset<Integer> buildObjectDataset() {
	    DataProvider<Integer> provider = new IntegerDataProvider();
		return new Dataset<Integer>(provider);		
	}

	@Override
	public int getDataRowCount() {
		return 100;
	}

}
]]>
</programlisting>
			</example>
			<para>If you run this test case now, you will see things light up
				like
				a
				Christmas tree. We have a lot of tests failing
				in some code
				that
				not only
				looked ok, but worked fine when we ran it. 
	</para>
			<figure>
				<title>Oh Noes! Epic Fail</title>
				<mediaobject>
					<imageobject role="fo">
						<imagedata align="center" fileref="../img/test_fail.png"
							scalefit="1" />
					</imageobject>
					<imageobject role="html">
						<imagedata align="center" fileref="../img/test_fail.png" />
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				The problem is subtle but involves on the old gotcha there are 101
				numbers
				from
				0 to 100 inclusive. The solution is
				fairly simple, we
				just need to define
				more
				closely what our dataset does. We'll make
				it
				so that it does return 100
				values
				in the range from 1 to 100, and
				we'll even add some test cases to
				ensure that
				it does. First lets
				alter the
				<methodname>fetchResults</methodname>
				method in our
				<classname>IntegerDataProvider</classname>
				class.
			</para>

			<example>
				<title>
					Revised
					<methodname>fetchResults</methodname>
					method in
					<code>IntegerDataProvider.java</code>
				</title>
				<programlisting role="JAVA">
<![CDATA[
	public List<Integer> fetchResults(Paginator paginator) {
		
		int start = paginator.getFirstResult()+1; //results start from 1
		
		int end = paginator.includeAllResults() ? 100 : 
		  Math.min(100, start+paginator.getMaxRows().intValue()-1);
		
		List<Integer> results = new ArrayList<Integer>();
		System.out.println("Generating results from "+start+" to "+(end));
		while (start <= end) {
			results.add(start++);			
		}
		paginator.setNextAvailable(end < 100);
		return results;
	}]]>
</programlisting>
			</example>
			<para>If you run the tests now you should pass with flying colors
				even
				though
				we only made very small changes. The test
				classes that
				can be
				used to test the
				implementations provide fairly good code
				coverage
				and can only get better over
				time
				as more tests are added.
			</para>
			<para>
				The
				<classname>AbstractObjectDatasetJUnitTest</classname>
				can only test how well the dataset lives up to its implementation of
				the
				<classname>DataProvider</classname>
				implementation, it cannot test the quality of the results. For that,
				we need
				to add our own tests to our class which
				we'll do now for the
				constraint that
				the numbers should range from 1 to 100. We will test
				it in two ways,
				paginated
				and non-paginated.
			</para>

			<example>
				<title>
					Additional tests in
					<classname>IntegerDataProviderTest.java</classname>
					to validate the results returned.
				</title>
				<programlisting role="JAVA">
<![CDATA[
	public void testResultsPaginated() {
		ObjectDataset<Integer> ds = buildObjectDataset();
		ds.setMaxRows(10);
		Integer expected = 1;
		while (ds.isNextAvailable()) {
			List<Integer> results = ds.getResultList();
			for (Integer i : results) {
				assertEquals(expected, i);
				expected = expected + 1;
			}
			ds.next();
		}

	}

	public void testResultsIterated() {
		ObjectDataset<Integer> ds = buildObjectDataset();
		ds.setMaxRows(10);
		Integer expected = 1;
		for (Integer i : ds) {
			assertEquals(expected, i);
			expected = expected + 1;
		}
	}

	public void testResultsNonPaginated() {
		ObjectDataset<Integer> ds = buildObjectDataset();
		ds.setMaxRows(null);
		Integer expected = 1;

		List<Integer> results = ds.getResultList();
		assertEquals(100, results.size()); //check size
		for (Integer i : results) {
			assertEquals(expected, i);
			expected = expected + 1;
		}
	}

]]>
</programlisting>
			</example>
			<para>Again, running these tests should provide a clean set of test
				results.
			</para>
		</sect1>
		<sect1>
			<title>
				Using our
				<classname>DataProvider</classname>
			</title>
			<para>
				We can now be pretty confident that our dataset works as expected
				with dozens
				of test cases behind it. Now we can go
				back to our
				<classname>Main</classname>
				class and start seeing how we access the data provided by this
				class.
			</para>
			<para>
				Data can be accessed from a provider in a number of ways,
				either
				paginated,
				non-paginated or using iterators
				(paginated or
				non-paginated). In our original
				example, we simple listed the first
				10 results. From the test code you
				might
				have seen a few more ways
				of accessing the data. First lets change our demo
				application to use
				an
				<classname>ObjectDataset</classname>
				instead of keeping separate
				<classname>Paginator</classname>
				and
				<classname>DataProvider</classname>
				references. The
				<classname>ObjectDataset</classname>
				combines these two interfaces and provides some benefits as we'll
				see.
			</para>
			<example>
				<title>
					Changing our demo application to use an
					<classname>ObjectDataset</classname>
				</title>
				<programlisting role="JAVA">
<![CDATA[
public static void main(String[] args) {
	ObjectDataset<Integer> ds = new Dataset<Integer>(new IntegerDataProvider());
	ds.setMaxRows(5);

	List<Integer> results = ds.getResultList();		
	showResults(results);			
}
]]>
</programlisting>
			</example>
			<para>If you run this now, it should run the same as before except
				for the
				fact that we changed the page size to 5 so
				we only return 5
				rows at a time for
				brevity. Let's add a second call to fetch the
				list of results and we'll see
				what
				happens.</para>
			<example>
				<title>
					Changing our demo application to use an
					<classname>ObjectDataset</classname>
				</title>
				<programlisting role="JAVA">
<![CDATA[
public static void main(String[] args) {
    DataProvider<Integer> provider = new IntegerDataProvider();
	ObjectDataset<Integer> ds = new Dataset<Integer>(provider);
	ds.setMaxRows(5);

	List<Integer> results = ds.getResultList();		
	showResults(results);
	showResults(ds.getResultList());			
}
]]>
</programlisting>
			</example>
			<figure>
				<title>Demo application results</title>
				<screen>			
Generating results from 1 to 5
Result Size = 5
Value = 1
Value = 2
Value = 3
Value = 4
Value = 5
Result Size = 5
Value = 1
Value = 2
Value = 3
Value = 4
Value = 5
</screen>
			</figure>
			<para>
				Unsurprisingly, we display the same list of numbers twice, but
				what
				is
				surprising is that we only generate the results
				the first
				time
				they are
				requested. The second time we call for the results,
				there is
				no message about
				generating
				results. This is because the
				<classname>ObjectDataset</classname>
				caches the results and only invalidates them when the pagination
				changes
				(i.e. the first result or page size is
				changed). You can
				manually force the
				results to be refreshed by calling
				<methodname>invalidateResults()</methodname>
				on the dataset. Doing so after the first call would force the
				dataset to
				re-fetch the data on the second call.
			</para>
			<para>
				This is one of the benefits of using a dataset on a thicker client
				or a
				stateful web app. The dataset can hold on to
				the results for
				you until you are
				done with them. Using separate
				<classname>Paginator</classname>
				and
				<classname>DataProvider</classname>
				instances can be useful in more stateless applications, or
				frameworks like
				Wicket that uses a detachable model that
				keeps hold
				of state, but lets you
				detach unwanted or re-fetchable state.
			</para>
			<sect2>
				<title>I want it all</title>
				<para>
					You can fetch all the results in the dataset by settings the
					<code>maxRows</code>
					to
					<code>null</code>
					. This means that when you call
					<code>getResults</code>
					you will get all the results from the
					<code>firstResult</code>
					index to the end. When you create a
					<classname>ObjectDataset</classname>
					by default, it is set up to fetch results from the first row and is
					not
					paginated so it will return all results from
					the beginning to
					the end.
				</para>
				<example>
					<title>Returning all results</title>
					<programlisting>
<![CDATA[
public static void main(String[] args) {
    DataProvider<Integer> provider = new IntegerDataProvider();
	ObjectDataset<Integer> ds = new Dataset<Integer>(provider);
	showResults(ds.getResultList());			
}
]]>
</programlisting>
				</example>
				<figure>
					<title>Returning all results</title>
					<screen>			
Generating results from 1 to 100
Result Size = 100
Value = 1
Value = 2
Value = 3
Value = 4
Value = 5
Value = 6
Value = 7
...
...
...
Value = 98
Value = 99
Value = 100
</screen>
				</figure>
			</sect2>
			<sect2>
				<title>Iteratively Speaking</title>
				<para>
					The dataset implements the
					<classname>Iterable</classname>
					interface which means that we can iterate over the dataset. If
					pagination is
					in use, it is performed transparently
					as you iterate
					through the dataset.
				</para>
				<example>
					<title>Returning all results</title>
					<programlisting>
<![CDATA[
public static void main(String[] args) {
    DataProvider<Integer> provider = new IntegerDataProvider();
	ObjectDataset<Integer> ds = new Dataset<Integer>(provider);
	ds.setMaxRows(5);
	for (Integer i : ds) {
		System.out.println("Iterating over value "+i);
	}		
}
]]>
</programlisting>
				</example>
				<figure>
					<title>Iterating over a paginated dataset</title>
					<screen>
Generating results from 1 to 5
Iterating over value 1
Iterating over value 2
Iterating over value 3
Iterating over value 4
Iterating over value 5
Generating results from 6 to 10
Iterating over value 6
Iterating over value 7
Iterating over value 8
Iterating over value 9
Iterating over value 10
Generating results from 11 to 15
Iterating over value 11
Iterating over value 12
...
...
...
terating over value 89
Iterating over value 90
Generating results from 91 to 95
Iterating over value 91
Iterating over value 92
Iterating over value 93
Iterating over value 94
Iterating over value 95
Generating results from 96 to 100
Iterating over value 96
Iterating over value 97
Iterating over value 98
Iterating over value 99
Iterating over value 100							
</screen>
				</figure>
				<para>This could be useful in cases where you want to group fetches
					into
					batches if fetches are expensive, or maybe
					even incorporate
					some
					multi-threading to let one thread fetch data and other threads
					to process
					result sets as they
					come in.</para>
			</sect2>
			<sect2>
				<title>Paging Datasets</title>
				<para>Generally paging through a dataset is done using the next and
					previous
					which changes the subset of data you are
					looking at.
					Generally speaking,
					using the iterator is the best way to iterate
					over every item in the dataset
					since
					paging is generally used to
					move to a specific page as to iterate
					through the data. </para>
				<para>Iterating manually is fraught with corner cases that could
					lead to a
					number of errors.</para>

				<example>
					<title>Attempting manual iteration</title>
					<programlisting>
<![CDATA[
//BROKEN CODE, DO NOT USE
while (ds.isNextAvailable()) {
	List<Integer> res = ds.getResultList();
	showResults(res);
	ds.next();
}
]]>
</programlisting>
				</example>
				<para>
					What happens here is that when we move to the last page using next,
					the
					<methodname>nextAvailable</methodname>
					property is set to false and we exit the loop before we display it.
					We could
					process the results after the loop but
					what happens when
					you forget to add
					the code at the end? The best demonstration of
					this is where the size of the
					result set is smaller than the page
					size, and when we fetch the first page
					of results,
					<methodname>nextAvailable</methodname>
					is false since this is the first and only page, and so we don't
					display the
					list.
				</para>
				<para>
					In general, use the dataset next/previous/first/last methods to
					navigate the
					dataset by moving from page to page and
					the
					<classname>Iterator</classname>
					implementation to go through the dataset item by item
					<superscript>*</superscript>
					. The iterator implementation handles all the corner cases in a
					familiar and
					consistent manner.
				</para>
				<para>
					Note that in the event of you reaching the end of the dataset
					and
					calling
					next, the active page will not change and
					you will
					receive
					the last result set
					back. Unless the dataset is empty,
					there will
					always be results returned in
					the
					result list, and if
					there are no
					results, an empty list should be
					returned. The results should never
					be
					<code>null</code>
					.
				</para>
				<note>
					<para>
						<superscript>*</superscript>
						We do use this kind of incorrect paging through data in
						some of the
						test
						cases, but only where we are not testing
						the
						number of
						results, but the
						actual result content, and we want to
						test the
						first/next/previous/last
						methods as
						opposed to the
						iterator
						implementation.
					</para>
				</note>
			</sect2>
			<sect2>
				<title>Manually Fetching Data</title>
				<para>
					As we discussed initially, the
					<classname>ObjectDataset</classname>
					is a helper construct that manages the two key interfaces of the
					<classname>Paginator</classname>
					and
					<classname>DataProvider</classname>
					. We can easily use these two classes separate very easily, there
					is no
					complex glue code implemented by the
					<classname>ObjectDataset</classname>
					except where it has provided enhanced features. Using two
					separately
					instantiated pagiantors and providers is very
					simple.
				</para>

				<example>
					<title>Manually creating provider and pagination instances and
						fetching
						results</title>
					<programlisting>
<![CDATA[
DataProvider<Integer> provider = new IntegerDataProvider();
Paginator paginator = new SimplePaginator(10);
List<Integer> results = provider.fetchResults(paginator);
showResults(results); 			
]]>
</programlisting>
				</example>
				<para>
					Each call to
					<methodname>fetchResults</methodname>
					executes the process to fetch the data. This can mean running a
					database
					query or parsing a file. The results are
					not cached unlike
					the
					<classname>ObjectDataset</classname>
					. This is because the
					<classname>DataProvider</classname>
					and
					<classname>Paginator</classname>
					instances are the raw building blocks that make up the
					<classname>ObjectDataset</classname>
					. In fact, as we'll see in the next chapter, these two classes,
					particularly the
					<classname>DataProvider</classname>
					is the building block for most of the framework.
				</para>
				<para>
					One important thing to bear in mind with using these components
					manually is
					that the
					<classname>DataProvider</classname>
					implementation is responsible for setting the
					<code>nextAvailable</code>
					property on the
					<classname>Paginator</classname>
					instance passed in to the
					<methodname>fetchResults</methodname>
					method. This means that when you first create a paginator, the
					<methodname>isNextAvailable</methodname>
					value is false so you cannot create a new paginator instance and
					call the
					<methodname>next()</methodname>
					method since it, as well as other functions, depends on the
					<code>nextAvailable</code>
					flag.
				</para>
				<para>One benefit of using these standalone components manually is
					that you
					can use multiple paginator instances to
					provide different
					views of
					the same
					dataset independent of each other. This can be
					useful when you want
					application
					scoped data with local pagination.
				</para>
				<example>
					<title>Multiple views of the same data</title>
					<programlisting>
<![CDATA[
DataProvider<Integer> provider = new IntegerDataProvider();
Paginator paginator1 = new DefaultPaginator(10);
Paginator paginator2 = new DefaultPaginator(15);
paginator1.setFirstResult(20);
paginator2.setFirstResult(30);
		
System.out.println("First result = "+paginator1.getFirstResult());
		
List<Integer> results1 = provider.fetchResults(paginator1);
List<Integer> results2 = provider.fetchResults(paginator2);
System.out.println("Result Set 1");
showResults(results1); 			
System.out.println("Result Set 2");
showResults(results2);
]]>
</programlisting>
				</example>
				<para>Here we obtain two different sets of data from a single data
					provider.
					This can let you re-use data providers
					that obtain data
					from expensive data
					sources.</para>
			</sect2>

		</sect1>
	</chapter>

	<chapter>
		<title>The JQA Architecture</title>
		<para>
			The last chapter introduced you to a number of concepts
			regarding how
			to use
			basic data providers controlled by an
			instance
			of a paginator,
			or abstracted
			through the object dataset
			implementations. Now we've
			covered these
			fundamentals
			we can expand our knowledge by looking at
			the different subclasses
			of the
			<classname>DataProvider</classname>
			interface and implementations for this is how we create datasets that
			can
			attach to different datasources in a useful
			way.
		</para>
		<para>
			Most subclasses of the
			<classname>DataProvider</classname>
			are mirrored in some form of
			<classname>ObjectDataset</classname>
			subclass which acts as a thick client wrapper around the data
			provider and
			internally uses an instance of that
			particular subclass.
		</para>
		<sect1>
			<title>
				<classname>ParameterizedDataProvider</classname>
			</title>
			<para>
				The first subclass of the
				<classname>DataProvider</classname>
				interface is the
				<classname>ParameterizedDataProvider</classname>
				that introduces methods for fetching data based on dynamic
				parameters.
			</para>
		</sect1>

		<sect1>
			<title>
				<classname>StatementDataProvider</classname>
			</title>
			<para>
				The
				<classname>StatementDataProvider</classname>
				extends the
				<classname>ParameterizedDataProvider</classname>
				and adds the ability to define string based statements for fetching
				and
				counting the number of rows of data. Since
				this extends the
				<classname>ParameterizedDataProvider</classname>
				we can let the user define statements that have parameters within
				them. This
				obviously lends itself to easily
				providing the bulk of
				features of a Sql or
				Ejbql or Hql data provider.
			</para>
		</sect1>

		<sect1>
			<title>
				<classname>QueryDataProvider</classname>
			</title>
			<para>
				The
				<classname>QueryDataProvider</classname>
				extends the
				<classname>StatementDataProvider</classname>
				and adds the ability to define restrictions and ordering.
			</para>
		</sect1>

	</chapter>
</book>
	