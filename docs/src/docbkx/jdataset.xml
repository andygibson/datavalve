<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<book>
	<title>JDataset Reference Guide</title>
	<titleabbrev>JDataset Ref</titleabbrev>
	<bookinfo>
		<author>
			<personname>
				<firstname>Andy</firstname>
				<surname>Gibson</surname>
			</personname>
		</author>
		<copyright>
			<year>2009</year>
			<holder>Andy Gibson</holder>
		</copyright>
	</bookinfo>
	<chapter id="Introduction">
		<title>Introduction</title>
		<para>
			The purpose behind this framework is to let developers access
			diverse
			sources of data in an easy and consistent
			manner. It also
			aims to augment the
			functionalities of existing data access
			mechanisms such as JDBC, Hibernate and
			JPA
			in a reusable manner.
		</para>
		<sect1>
			<title>The Itch</title>
			<para>
				When starting a new data driven application you typically need
				some
				mechanism to query data with the following
				capabilities:
		</para>
			<itemizedlist>
				<listitem>
					<para>Pagination of large datasets</para>
				</listitem>
				<listitem>
					<para>Dynamic Ordering (for clickable columns)</para>
				</listitem>
				<listitem>
					<para>Lazy Loading of data</para>
				</listitem>
				<listitem>
					<para>Optional restrictions in the query for when parameter values
						are
						missing</para>
				</listitem>
				<listitem>
					<para>The ability to apply a common front end to the back end query
						mechanism so you can reuse both pieces to
						implement forms in
						minutes.</para>
				</listitem>
			</itemizedlist>
			<para>
				As a long time Seam user, Seam provides most of this with the
				<classname>EntityQuery</classname>
				that can be used to run queries using JPA but it isn't perfect. I
				extended
				the Seam
				<classname>EntityQuery</classname>
				and
				<ulink
					url="http://www.andygibson.net/blog/index.php/2008/10/02/codeless-ajax-ordered-and-paginated-tables-in-seam/">blogged about it </ulink>
				and it still remains a popular article today and one I get most
				emails about
				when people are looking for JSF and
				pagination.
				However, this still has
				problems since it only works in Seam projects
				but the same functionality is
				needed
				in Wicket, Spring, JSP and even
				Swing and console apps. Other
				frameworks such as Wicket provided an
				interface for
				handling ordered paginated
				datasets, but the
				implementation was
				usually up to the user as this was beyond
				the
				scope of
				Wicket.
			</para>

			<para>The other source of inspiration is from Borland Delphi which
				worked on
				the idea that a common data access
				interface meant that
				data driven components
				could access data without considering where
				it came from. A standard query
				interface means we can create a
				reusable front end. Third party Delphi
				component developers could
				create data access
				components that would work with
				any kind of data
				source, from Oracle, MySQL and MS Access to XML or file
				based
				datasets as long as there was a dataprovider implementation for it.
				When
				developing in Java, you typically have to code
				against a common but
				more
				precise back end such as a JDBC query and write new interfaces
				for different
				view
				technologies.
			</para>
			<para>It seems that all these frameworks recognized the need to
				access data in
				a uniform way, but it was beyond the
				scope of the
				frameworks to provide it,
				and the scope of what they did provide was
				usually limited to their own
				framework. Without a uniform data
				access mechanism developers have to write
				and re-write their front
				and back ends
				every time they start a new project or
				want to re-use
				some existing code from a different view technology.
			</para>
			<figure>
				<title>Projects without using JDatasets</title>
				<mediaobject>
					<imageobject role="fo">
						<imagedata align="center" fileref="../img/app_without_jds.png"
							scalefit="1" />
					</imageobject>
					<imageobject role="html">
						<imagedata align="center" fileref="../img/app_without_jds.png" />
					</imageobject>
				</mediaobject>
			</figure>


		</sect1>

		<sect1>
			<title>The Solution</title>
			<para>So, I scratched my own itch and created this project that
				defines a
				common API for querying diverse data sources
				with
				pagination and optionally
				with ordering, restrictions and
				parameters. This lets us write common view
				code that
				can interface
				with queries that are interchangeable. 
			</para>
			<figure>
				<title>Projects using JDatasets</title>
				<mediaobject>
					<imageobject role="fo">
						<imagedata align="center" fileref="../img/app_with_jds.png"
							scalefit="1" />
					</imageobject>
					<imageobject role="html">
						<imagedata align="center" fileref="../img/app_with_jds.png" />
					</imageobject>
				</mediaobject>
			</figure>
			<sect2>
				<title>Architecture</title>
				<para>
					JQA is organized into two main interfaces called
					<classname>Paginator</classname>
					and
					<classname>DataProvider</classname>
					. The
					<classname>Paginator</classname>
					holds the state about our dataset such as the order information,
					the page
					size and the current page. The
					<classname>DataProvider</classname>
					interface defines two simple methods which are used to fetch the
					total
					number of rows in the dataset, and a (sub)set
					of the items in
					the
					dataset.
				</para>
				<example>
					<title>
						The
						<classname>DataProvider</classname>
						interface
					</title>
					<programlisting role="JAVA">
<![CDATA[
public interface DataProvider<T> {
	Integer fetchResultCount();
	List<T> fetchResults(Paginator paginator);
}
]]>
					</programlisting>
				</example>
				<para>
					When we fetch the results, we pass in the paginator so the
					<classname>DataProvider</classname>
					implementation knows which rows to return and it can set the flag
					indicating whether there are more results or not.
				</para>
			</sect2>
			<sect2>
				<title>Benefits of Java Query Adapters</title>
				<para>
					Even if you still plan on using a single data access mechanism
					(i.e.
					Hibernate or JPA) there are still
					advantages to using Java
					Query
					Adapters.
				</para>

				<sect3>
					<title>Interchangable query mechanisms</title>
					<para>
						Most projects plan on using only one data access mechanism but by
						coding to the JQA API, you can switch implementations later. You
						might move
						from JPA to Hibernate or even to plain JDBC queries and most of
						the code
						that uses these queries, including parameterized queries, will
						remain the
						same. There may also be times where you need to access different types of
						data stores such as a file based
						datasource updated nightly which needs
						accessing and displaying.  
					</para>
					<para>Regardless of where the different types of datastores come from, with
						JQA you will be able to access them and control the results using your
						existing view code to paginate and order the data. Even if you don't see
						yourself switching data access mechanisms or having to access diverse data
						stores, you may want to just switch the query here and there from a pure
						ORM type query to a JDBC SQL query but still want to interface with the
						data the same way you do with your other queries.
					</para>
				</sect3>

				<sect3>
					<title>Easy Querying</title>
					<para>JQA makes it easier to query for the data
						you need. It
						features
						flexible parameter definition by setting the
						value
						manually, using EL
						expressions, extracting the values using
						reflection or your own custom
						parameter resolver.
						Parameters that
						don't have a value assigned can
						optionally be left out of the
						query which can be useful when you are
						writing search forms where
						the user may leave out search criteria and you
						don't want it
						included in the query. Doing
						this manually can lead to
						messy
						code that is hard to read, test and maintain.
					</para>
					<example>
						<title>
							Coding search queries the hard way.
                    </title>
						<programlisting role="JAVA">
<![CDATA[
String sql = "";
if (searchCriteria.id != null  
  && searchCriteria.id.length() != 0) {
    if (sql.length()!= 0) {
      sql = sql + " AND ";
    }
    sql= sql+ "p.id = :id";
    paramsMap("id",searchCriteria.id);
}

if (searchCriteria.firstName != null  
  && searchCriteria.firstName.length() != 0) {
    if (sql.length()!= 0) {
      sql = sql + " AND ";
    }
    sql= sql+ "p.firstName = :firstName";
    paramsMap("firstName",searchCriteria.firstName);
}

if (searchCriteria.lastName != null  
  && searchCriteria.lastName.length() != 0) {
    if (sql.length()!= 0) {
      sql = sql + " AND ";
    }
    sql= sql+ "p.lastName = :lastName";
    paramsMap("lastName",searchCriteria.lastName);
}

if (sql.length() != 0) {
  sql = " WHERE " + sql;
}
sql = [select statement] + sql;

qry = createQuery(sql);
for (String key : paramsMap.keySet) {
  qry.setParameter(key,paramsMap.get(key))
}

List<Person> results = qry.resultList();
]]>
					</programlisting>

					</example>
					<para>With JQA, you can define the query, specify
						how the
						parameters are
						resolved and the data provider
						will take care of
						generating
						the right request
						so that
						the only
						restrictions included in the
						query are ones with parameter
						values
						assigned.</para>
					<example>
						<title>
							Coding search queries the easy way.
                    </title>
						<programlisting role="XML">
<![CDATA[
qry.addRestriction("p.id = :id");
qry.addRestriction("p.firstName = :firstName");
qry.addRestriction("p.lastName = :lastName");
ParameterResolver resolver = 
  new ReflectionParameterResolver(searchCriteria));
qry.addParameterResolver(resolver);
List<Person> results = qry.resultList();]]>
					</programlisting>
					</example>
				</sect3>


				<sect3>
					<title>Flexible and Secure Ordering Abstraction</title>
					<para>JQA lets you order your data base on order key values as
						opposed to
						explicit table column values which could
						be prone to SQL
						injection attacks.
						By using an orderKey value which is translated
						server side into a
						query
						level
						representation, you can control what
						values are used
						for setting the
						order of the dataset ensuring no
						harmful
						SQL is
						inserted into your query.
					</para>
				</sect3>
				<sect3>
					<title>Convert anything into a dataset</title>
					<para>At the heart of JQA is a simple API which allows you to turn
						anything
						into a source of data that can be accessed and
						paginated from
						existing view
						code.
						This can range from custom datasources or
						third party applications to
						text, csv
						or binary file sources or
						even just a static in-memory list of
						objects.
					</para>
				</sect3>
			</sect2>
		</sect1>
		<sect1>
			<title>Architecture</title>
			<para>
				This section covers the architecture of the framework and how
				they all
				relate to each other.</para>
			<sect2>
				<title>Main API</title>
				<para>
					The main API consists of the
					<classname>Paginator</classname>
					and
					<classname>DataProvider</classname>
					interfaces. The Paginator is like a bookmark for a dataset and holds
					the
					current record, page size and ordering
					information as well as
					flags
					indicating
					whether there is a previous or next page available.
					Inversely, the
					<classname>DataProvider</classname>
					is the stateless part of the equation. It provides the data based on the
					state of the
					paginator passed in.
				</para>
				<example>
					<title>Fetching data from a provider</title>
					<programlisting>
<![CDATA[				
  DataProvider prov = new CustomDataProvider();
  Paginator paginator = new DefaultPaginator();
  List<ResultClass> results = prov.fetchResults(paginator);
  Integer count = prov.getResultCount();  
]]>  
				</programlisting>
				</example>
				<para>
					This is a simple example where we create an instance of our custom provider
					that knows how
					to fetch the data. We create an instance of a
					<classname>Paginator</classname>
					and when we fetch the results we pass that in to the data provider to
					tell
					the
					provider which set of data to return. In
					this case, we
					returned all the
					data
					but by setting properties on the paginator we
					can tell the provider just
					to
					return
					a subset. The provider is also responsible for setting the flag in
					the paginator indicating whether there are more results.
				</para>
				<example>
					<title>Limiting the data fetched from a data provider</title>
					<programlisting>
<![CDATA[				
  DataProvider prov = new CustomDataProvider();
  Paginator paginator = new DefaultPaginator();
  paginator.setMaxRows(10);
  paginator.setFirstResult(35);
  List<ResultClass> results = prov.fetchResults(paginator);
  Integer count = prov.fetchResultCount();
    
]]>  
				</programlisting>
				</example>
				<para>
					Here we set the maximum number of rows to return to 10 and we want the
					first
					result to start at item number 35. The implementation of the
					<classname>CustomProvider</classname>
					is responsible for returning the correct subset of data to the caller. It
					is
					also responsible for setting the
					<code>nextAvailable</code>
					flag on the paginator. This keeps track of whether there are more results
					available or not.
				</para>
				<para>
					If you were to call
					<methodname>fetchResults</methodname>
					a second time, the provider would go off and re-fetch the data executing
					whatever process it does to fetch the data. It does not cache the data in
					anyway and should be implemented statelessly such that one call to the
					provider is independent of any other calls to the provider.
				</para>
				<para>
					The third part of the API is an
					<classname>ObjectDataset</classname>
					which combines both the provider and paginator information into one
					class
					and
					can be used to manage the fetched data.
					This component
					should be
					considered
					stateful as it holds on to the results and
					caches them. This piece
					is very
					similar
					to the
					<classname>EntityQuery</classname>
					component in Seam. It also lets you iterate over the dataset easily and
					doing so
					will also take pagination into account. Datasets have the stateful
					pagination content built in and refer to a data provider to supply the
					data.
				</para>
				<example>
					<title>
						Using an
						<classname>ObjectDataset</classname>
					</title>
					<programlisting>
<![CDATA[				
  DataProvider provider = new CustomDataProvider();
  Dataset<SomeClass> dataset = new Dataset(provider);
  dataset.setMaxRows(10);
  dataset.setFirstResult(35);
  List<ResultClass> results = dataset.getResults();
  for (SomeClass item : dataset) {
    ...some code...
  }
]]>  
				</programlisting>
				</example>
				<para>
					The
					<classname>ObjectDataset</classname>
					incorporates its own
					<classname>Paginator</classname>
					and works on the data provider passed in to the constructor. Repeated calls
					to
					<methodname>getResults()</methodname>
					without changing the pagination information will cause the exact same
					results to be returned since the current page of results is held by the
					dataset.
				</para>
			</sect2>
		</sect1>
	</chapter>
	<chapter>
		<title>Database Driven Providers</title>
		<para>
			While JQA offers a way to access many different types of data stores, in most
			cases, you will want to fetch data from a database. JQA comes with data
			providers for fetching data using JPA, Hibernate or just plain SQL via JDBC.
			These different providers are based off and implement the
			<classname>QueryDataProvider</classname>
			. This interface adds features such as ordering, restrictions and parameters
			for flexible querying. Note that since they implement the same interface,
			they can be interchanges with very little code changes if any.
		</para>
		<sect1>
			<title>Simple Fetches</title>
			<para>
				Let's start by considering some simple cases of fetching data using a
				data
				driven query. First we create the data provider that will fetch the data
				for us, and then we create the dataset that we will use to access the data.
			</para>
			<example>
				<title>
					Fetching data from a database using JPA					
				</title>
				<programlisting>
<![CDATA[

  QueryProvider<Person> provider = new JpaDataProvider<Person>(em);
  QueryDataset<Person> dataset = new QueryDataset<Person>(provider);
  provider.setSelectStatement("select p from Person p");
  provider.setCountStatement("select count(p) from Person p");
  List<Person> results = dataset.getResultList();
  for (Person p : results) {
    System.out.println(p.getName());
  }
]]>  
				</programlisting>
			</example>
		</sect1>
		<sect1>
			<title>Restricting Results</title>
			<para>
				We can add restrictions to the query so we only return a set of rows
				that we
				want. In this case, we want to return a specific person. The above
				code to create and initialize the data provider has neem rolled into a
				method to return the person data provider.
		</para>

			<example>
				<title>
					Restricting the data fetched					
				</title>
				<programlisting>
<![CDATA[  
  QueryDataProvider<Person> provider = createPersonProvider();
  provider.addRestriction("p.id = 4");  
]]>  
				</programlisting>
			</example>


			<para>
				It is often more convenient to specify limitations using parameters
				and
				JQA
				has a number of different mechanisms with which to specify
				parameterized
				restrictions. First we'll look at adding
				constant parameters. We can add the
				restriction with the keyword
				<code>:param</code>
				where the parameterized value is meant to go and pass the parameter with the
				restriction. We can also add the restriction with the name of the parameter
				and set the parameter on the data provider separately.
				The first two syntaxes
				rename the parameter and puts the values in the internal parameter map. The
				last syntax keeps the parameter name you passed in and is useful if you
				anticpate changing that parameter since you know what name it has.
			</para>

			<example>
				<title>
					Restricting Results with Constant Parameters					
				</title>
				<programlisting>
<![CDATA[  
  QueryDataProvider<Person> provider = createPersonProvider();
  
  //add parameter using :param keyword in restriction
  provider.addRestriction("p.id = :param",4);
  provider.addRestriction("p.firstName = :param","John");
  
  //add parameter manually
  provider.addRestriction("or p.lastName = :lastNameParam");
  provider.addParameter("lastNameParam","Smith");
]]>  
				</programlisting>
			</example>
			<para>
				In many cases, we don't want to include restrictions where the value we
				are
				comparing is
				<code>null</code>
				, such as search forms where the user has left values
				blank. In these cases,
				any restriction with null parameter should not be included. In this example,
				we only add the first and last name restrictions if the values are set.
			</para>
			<example>
				<title>
					Restricting with non-constant parameters					
				</title>
				<programlisting>
<![CDATA[  
  QueryDataProvider<Person> provider = createPersonProvider();
  provider.addRestriction("p.firstName = :param",searchCriteria.firstName);
  provider.addRestriction("p.lastName = :param",searchCriteria.lastName);
]]>  
				</programlisting>
			</example>
			<para>
				These are really just helper methods so you don't have to do your own "
				<code>if value != null then add parameter</code>
				" code for each line, although it is certainly possible that you can do
				that
				in certain cases. There is also an overloaded version of this function
				specifically for strings which will check not only for null values but for a
				length of zero.
			</para>
			<para>
				Many times you want to evaluate one value to see if is null but use
				another value for the actual parameter to query with. We have a method for
				that too.
			</para>
			<example>
				<title>
					Alternate Value Parameters					
				</title>
				<programlisting>
<![CDATA[  
  QueryDataProvider<Person> provider = createPersonProvider();
  provider.addRestriction("p.firstName like :param",searchCriteria.firstName,searchCriteria.firstName+"%");
  provider.addRestriction("p.lastName like :param",searchCriteria.lastName,searchCriteria.lastName+"%");
]]>  
				</programlisting>
			</example>
			<para>
				What we do there is check whether the first/last name value is null and
				if so we ignore the restriction, but otherwise we add the restriction and we
				use the value with a wildcard added as the parameter value. 
			</para>
			<para>This may seem a fairly broad set of ways to parameterize the your
				queries, but is only the first way of two parameter definition mechanisms
				with the second being the use of parameter resolvers.</para>
		</sect1>
		<sect1>
			<title>Parameter Resolvers</title>
			<para>
				The
				<code>ParameterResolver</code>
				interface can be used to implement objects that can be attached to the
				data
				provider at run time to resolve
				parameters. When the query is executed
				the
				parameters are evaluated as the
				query is built so any restrictions with
				null
				parameters can be excluded. We
				attach parameter resolvers to the
				provider so
				it will be used when the
				provider tries to resolve the parameter
				for a
				restriction. This mechanism
				allows us to attach an EL parameter
				resolver for
				environments where EL is in
				use.
			</para>
			<para>It also lets use different mechanisms for resolving values such as
				using reflection onto a an object, or even returning parameter values based
				on the name directly.</para>
			<example>
				<title>
					Parameter Resolving with Reflection					
				</title>
				<programlisting>
<![CDATA[  
  QueryDataProvider<Person> provider = createPersonProvider();
  provider.addRestriction("p.firstName like :firstName");
  provider.addRestriction("or p.lastName like :lastName");
  provider.addParameterResolver(new ReflectionParameterResolver(searchCriteria));
]]>  
				</programlisting>
			</example>
			<para>We can also bake the parameter resolver into the object directly by
				making it implement the parameter resolver interface.</para>
			<example>
				<title>
					Built in parameter resolution					
				</title>
				<programlisting>
<![CDATA[  
public class SearchCriteria implements ParameterResolver {

    //return values with wildcards
	boolean resolveParameter(ParameterizedDataProvider<? extends Object> dataset,
			Parameter parameter) {
			if ("firstName".equals(parameter.getName())) {			  
			  return firstName == null ? null : firstName+"%";
			}
			if ("lastName".equals(parameter.getName())) {			  
			  return lastName == null ? null : lastName+"%";
			}
			return null;
    }

	boolean acceptParameter(String name) {
	  return name.startsWith(":");
	}

}

...
...
...

  QueryDataProvider<Person> provider = createPersonProvider();
  provider.addRestriction("p.firstName = :firstName");
  provider.addRestriction("or p.lastName = :lastName");
  provider.addParameterResolver(searchCriteria);
]]>  
				</programlisting>
			</example>
			<para>
				The Seam and CDI data provider classes use an EL based parameter resolver so
				you can use it the same way you would with a Seam
				<classname>EntityQuery</classname>
				.
			</para>

			<example>
				<title>
					Using the Seam data provider 					
				</title>
				<programlisting>
<![CDATA[  
@Name("myPostsQuery")
pulic class MyPostsQueryBean extends SeamJpaQueryDataset{
  public MyPostsQueryBean() {
    setSelectStatement("select p from Posts p left join fetch p.comments");
    setCountStatement("select count(p) from Posts p");    
    addRestriction("p.author.id = #{loggedInUser.id}");
  }
}
]]>  
				</programlisting>
			</example>
			<para>
				On the subject of Seam, with JQA you can subclass either a
				<classname>SeamJPaQueryDataset</classname>
				or a
				<classname>SeamJpaNativeDataset</classname>
				so you can use either a Ejbql or Native query for fetching data. Also, there
				is an adapter class that can be used instead which adds on the additional
				methods needed to make the class compatible with
				<classname>EntityQuery</classname>
				based classes.
			</para>
		</sect1>
		<sect1>
			<title>Order in the house</title>
			<para>
				JQA also features key based ordering so rather than specify ordering as
				a set
				of fields on the dataset, you can specify ordering using a key that
				maps to
				one or more fields. 
			</para>
			<example>
				<title>
					Ordering on the data
				</title>
				<programlisting>
<![CDATA[  
  QueryDataProvider<Person> provider = createPersonProvider();  
  provider.addRestriction("p.lastName = 'SMITH'");
  provider.getOrderKeyMap().put("name","p.lastName,p.firstName");
  provider.getOrderKeyMap().put("age","p.dateOfBirth");
  provider.getOrderKeyMap().put("id","p.id");
  //now set the order
  Paginator paginator = new DefaultPaginator();
  paginator.setOrderKey("name");  //order by the persons name
  paginator.setOrderAscending(false);
  
  List<Person> orderedList = provider.fetchResults(paginator):
]]>  
				</programlisting>
			</example>
			<para>
				The order information consists of the
				<code>orderKey</code>
				attribute that indicates the order to use and the
				<code>orderAscending</code>
				attribute indicates whether it is meant to be
				ascending or descending. Both
				of these attributes are on the
				<classname>Paginator</classname>
				interface and are read when it is passed into the
				<methodname>fetchResults</methodname>
				method.
				Note that in this example, the ordering for the
				key "name" has two
				fields, last
				and
				first
				name to sort on. If this key is used
				to order then both
				these fields
				will be
				used to
				order and the framework takes
				care of
				ascending/descending
				issues.
			</para>
			<para>
				By abstracting the ordering mechanism we can use
				the same
				idea for defining
				ordering on non-database data providers. The key for
				example might map to a
				<classname>Comparator</classname>
				instance that can be used to sort the in-memory dataset.
			</para>
		</sect1>
		<sect1>
			<title>Polymorphism</title>
			<para>
				One of the best features here is that in order to switch from Hibernate to
				JPA, or another data driven implementation, all we need to change is our
				<methodname>createPersonProvider()</methodname>
				method. Following good principles, we have been coding to an interface and
				not an actual class type so we are not locked in to using a concrete class,
				but any class that implements the
				<classname>QueryDataProvider</classname>
				interface. Currently, there are
				<classname>QueryDataProvider</classname>
				implementations for SQL/JDBC, Hibernate and JPA. The JPA versions
				include
				both Ejbql and Native querying as do the Seam extensions for the JPA
				providers.
			</para>
			<para>
				You could easily return a Hibernate data provider from the
				<methodname>createPersonProvider</methodname>
				without having to change any code since the mappings will be the same. At
				most you might have to change the base select/count statement or any complex
				where
				clauses.
			</para>
		</sect1>
		<sect1>
			<title>Mapping SQL to Objects</title>
			<para>One problem so far is that our data providers always deal with objects
				natively because that is what Hibernate and JPA do.
				Our SQL based datasets
				are fetching data as a set of rows of values instead of actual
				objects so we
				still need some way to convert that raw data
				into an object that can be
				returned in our results.</para>
			<para>
				This can be done in one of two ways but both involve a
				<classname>java.sql.ResultSet</classname>
				and building an instance of our model objects from the current row of data.
			</para>
			<para>
				The first method is to subclass the
				<classname>AbstractJdbcDataProvider</classname>
				and override the
				<methodname>createObjectFromResultSet</methodname>
				method. This uses the template pattern to provide the missing functionality
				needed to convery SQL data into an actual object.
			</para>
			<example>
				<title>
					Implementing the SQL to Object mapping
				</title>
				<programlisting>
<![CDATA[

public class PersonDataProvider extends AbstractJdbcDataprovider<Person> {
  public T createObjectFromResultSet(ResultSet resultSet) throws SQLException {
    return new Person(resultSet.getLong(1), resultSet.getString(2),
	    resultSet.getString(3));
  }
}  
]]>  
				</programlisting>
			</example>
			<para>
				Some people prefer to use a strategy pattern over a template pattern so we
				have an implementation for that also. The
				<classname>ResultSetObjectMapper</classname>
				interface provides a method to take a
				<classname>
					javax.sql.ResultSet
				</classname>
				and return an object for the current row in the results. The
				<classname>JdbcDataProvider</classname>
				class takes a reference to a
				<classname>ResultSetObjectMapper</classname>
				instance and uses it to convert the raw SQL rows to an object.
			</para>

			<example>
				<title>
					SQL to Object mapping using an external mapper.
				</title>
				<programlisting>
<![CDATA[
public class PersonObjectMapper implements ResultSetObjectMapper<Person> {

    public Person createObjectFromResultSet(ResultSet resultSet) throws SQLException {
	return new Person(resultSet.getLong(1),resultSet.getString(1),resultSet.getString(2));
    }
		
}


public QueryDataProvider<Person> createDataProvider() {
  JdbcDataProvider<Person> prov = new JdbcDataProvider<Person>();
  prov.setResultSetObjectMapper(new PersonObjectMapper());
  return prov;
}]]>  
				</programlisting>
			</example>
			<para>This kind of construction can be taken care of by any dependency
				injection framework you are using.</para>
		</sect1>

	</chapter>
	<chapter>
		<title>Implementing and Testing a Data Provider</title>
		<para>This chapter looks at creating a simple data provider, testing
			it and
			seeing the different ways we can access the
			data in it.</para>
		<sect1>
			<title>
				Our first
				<classname>DataProvider</classname>
			</title>
			<para>
				Let us start by seeing how the different parts and pieces connect by
				creating a new provider that
				lists the
				numbers
				from 1 to 100 and
				we
				will access
				it in different ways. We'll start
				by
				writing our data
				provider
				that implements
				the
				<classname>DataProvider&lt;Integer&gt;</classname>
				interface.
			</para>
			<example>
				<title>
					<code>IntegerDataProvider.java</code>
				</title>
				<programlisting role="JAVA">
<![CDATA[
public class IntegerDataProvider implements DataProvider<Integer>,Serializable {

	public Integer fetchResultCount() {
		return 100;
	}

	public List<Integer> fetchResults(Paginator paginator) {
		
		int start = paginator.getFirstResult();
		
		int end = paginator.includeAllResults() ? 100 : 
		  Math.min(100, start+paginator.getMaxRows().intValue()-1);
		
		List<Integer> results = new ArrayList<Integer>();
		System.out.println("Generating results from "+start+" to "+end);
		while (start <= end) {
			results.add(start++);			
		}
		paginator.setNextAvailable(end < 100);
		return results;
	}
}
]]>
			</programlisting>
			</example>
			<para>
				The
				<methodname>fetchResultCount()</methodname>
				method returns a constant value of 100 in this case because we are
				dealing
				with a fixed range of integers. Typically
				though, this will
				return the number
				of items in the complete dataset and is used to
				determine the number pages
				available.
			</para>
			<para>
				The
				<methodname>fetchResults</methodname>
				methods takes a paginator and generates the list of integers to
				return to the
				user. The list is based on two things,
				the
				<code>firstResult</code>
				value that determines which page we are on and therefore where to
				start
				counting from, and the
				<code>maxRows</code>
				value that determines how many results to return. If
				<code>maxRows</code>
				is set to null then we are returning all rows, and we have the
				utility method
				<methodname>includeAllResults</methodname>
				to make it easier to check this. Once we have determined the start
				and end
				points to count from and to, we build the
				list of results,
				and before
				returning it, we set the flag for indicating whether
				there
				are more results
				available. This
				is the responsibility of the
				data
				provider because only it
				knows whether there are more results.
			</para>
			<para>Next, we'll create a client for this provider as a simple class
				that
				just fetches the results and lists them.
			</para>
			<example>
				<title>
					<code>IntegerDataProvider.java</code>
				</title>
				<programlisting role="JAVA">
<![CDATA[
public class Main {

	public static void main(String[] args) {
		Paginator paginator = new DefaultPaginator(10);
		DataProvider<Integer> provider = new IntegerDataProvider();		

		List<Integer> results = provider.fetchResults(paginator);
		showResults(results);
	}

	public static void showResults(List<Integer> results) {
		System.out.println("Result Size = " + results.size());

		for (Integer i : results) {
			System.out.println("Value = " + i);
		}
	}
}	
]]>
</programlisting>
			</example>

			<para>
				In the
				<methodname>main</methodname>
				method, we create a new
				<classname>DefaultPaginator</classname>
				instance that implements the
				<classname>Paginator</classname>
				interface. We pass our initial page size into the constructor so we
				will
				start by returning 10 rows at a time. We
				then create an
				instance
				of our data
				provider, and call the
				<methodname>fetchResults</methodname>
				method to return the first page of results. We then pass the results
				to the
				<methodname>showResults</methodname>
				method which just displays the number of results. If we run this, we
				get the
				expected list of numbers from 0 to 9
				with a page size of 10.
			</para>
			<example>
				<title>
					Execution Results
				</title>
				<programlisting role="JAVA">
<![CDATA[
Generating results from 0 to 9
Result Size = 10
Value = 0
Value = 1
Value = 2
Value = 3
Value = 4
Value = 5
Value = 6
Value = 7
Value = 8
Value = 9
]]>
</programlisting>
			</example>
			<para>
				So everthing looks fine, this is the result we expected so we
				must
				have
				a
				working dataset right? Well not so fast.
				Let's create a
				test case
				for
				it first.
				Since we are working with well defined
				interfaces we can
				define a test case
				that
				tests the interface and
				make
				sure our
				implementation is meeting the
				contract defined by the
				interface.
			</para>
		</sect1>
		<sect1>
			<title>
				Testing our
				<classname>DataProvider</classname>
			</title>
			<para>
				Create a new class (in the test packages if applicable) and create
				it
				as a
				subclass of
				<classname>package
					org.jdataset.testing.junit.AbstractObjectDatasetJUnitTest
				</classname>
				. This class defines two methods which needs to be implemented in
				subclasses. The
				<methodname>getDataRowCount()</methodname>
				returns the number of rows expected in the dataset and the
				<methodname>buildObjectDataset</methodname>
				method returns an instance of an
				<classname>ObjectDataset</classname>
				. An
				<classname>ObjectDataset</classname>
				is a class that combines a
				<classname>Paginator</classname>
				and a
				<classname>DataProvider</classname>
				implementation in one class for convenience. We can easily create
				one
				by
				creating an instance of a
				<classname>org.jdataset.impl.Dataset</classname>
				and pass it an instance of our
				<classname>IntegerDataProvider</classname>
				which the dataset will use to obtain data.
				.
			</para>

			<example>
				<title>
					<code>IntegerDataProvider.java</code>
				</title>
				<programlisting role="JAVA">
<![CDATA[
public class IntegerDataProviderTest extends 
  AbstractObjectDatasetJUnitTest<Integer> {

	@Override
	public ObjectDataset<Integer> buildObjectDataset() {
	    DataProvider<Integer> provider = new IntegerDataProvider();
		return new Dataset<Integer>(provider);		
	}

	@Override
	public int getDataRowCount() {
		return 100;
	}

}
]]>
</programlisting>
			</example>
			<para>If you run this test case now, you will see things light up
				like
				a
				Christmas tree. We have a lot of tests failing
				in some code
				that
				not only
				looked ok, but worked fine when we ran it. 
	</para>
			<figure>
				<title>Oh Noes! Epic Fail</title>
				<mediaobject>
					<imageobject role="fo">
						<imagedata align="center" fileref="../img/test_fail.png"
							scalefit="1" />
					</imageobject>
					<imageobject role="html">
						<imagedata align="center" fileref="../img/test_fail.png" />
					</imageobject>
				</mediaobject>
			</figure>
			<para>
				The problem is subtle but involves on the old gotcha there are 101
				numbers
				from
				0 to 100 inclusive. The solution is
				fairly simple, we
				just need to define
				more
				closely what our dataset does. We'll make
				it
				so that it does return 100
				values
				in the range from 1 to 100, and
				we'll even add some test cases to
				ensure that
				it does. First lets
				alter the
				<methodname>fetchResults</methodname>
				method in our
				<classname>IntegerDataProvider</classname>
				class.
			</para>

			<example>
				<title>
					Revised
					<methodname>fetchResults</methodname>
					method in
					<code>IntegerDataProvider.java</code>
				</title>
				<programlisting role="JAVA">
<![CDATA[
	public List<Integer> fetchResults(Paginator paginator) {
		
		int start = paginator.getFirstResult()+1; //results start from 1
		
		int end = paginator.includeAllResults() ? 100 : 
		  Math.min(100, start+paginator.getMaxRows().intValue()-1);
		
		List<Integer> results = new ArrayList<Integer>();
		System.out.println("Generating results from "+start+" to "+(end));
		while (start <= end) {
			results.add(start++);			
		}
		paginator.setNextAvailable(end < 100);
		return results;
	}]]>
</programlisting>
			</example>
			<para>If you run the tests now you should pass with flying colors
				even
				though
				we only made very small changes. The test
				classes that
				can be
				used to test the
				implementations provide fairly good code
				coverage
				and can only get better over
				time
				as more tests are added.
			</para>
			<para>
				The
				<classname>AbstractObjectDatasetJUnitTest</classname>
				can only test how well the dataset lives up to its implementation of
				the
				<classname>DataProvider</classname>
				interface, it cannot test the quality of the results. For that,
				we need
				to add
				our own tests to our class which
				we'll do now for the
				constraint that
				the
				numbers should range from 1 to 100. We will test
				it in two ways,
				paginated
				and
				non-paginated.
			</para>

			<example>
				<title>
					Additional tests in
					<classname>IntegerDataProviderTest.java</classname>
					to validate the results returned.
				</title>
				<programlisting role="JAVA">
<![CDATA[
	public void testResultsPaginated() {
		ObjectDataset<Integer> ds = buildObjectDataset();
		ds.setMaxRows(10);
		Integer expected = 1;
		while (ds.isNextAvailable()) {
			List<Integer> results = ds.getResultList();
			for (Integer i : results) {
				assertEquals(expected, i);
				expected = expected + 1;
			}
			ds.next();
		}

	}

	public void testResultsIterated() {
		ObjectDataset<Integer> ds = buildObjectDataset();
		ds.setMaxRows(10);
		Integer expected = 1;
		for (Integer i : ds) {
			assertEquals(expected, i);
			expected = expected + 1;
		}
	}

	public void testResultsNonPaginated() {
		ObjectDataset<Integer> ds = buildObjectDataset();
		ds.setMaxRows(null);
		Integer expected = 1;

		List<Integer> results = ds.getResultList();
		assertEquals(100, results.size()); //check size
		for (Integer i : results) {
			assertEquals(expected, i);
			expected = expected + 1;
		}
	}

]]>
</programlisting>
			</example>
			<para>Again, running these tests should provide a clean set of test
				results.
			</para>
		</sect1>
		<sect1>
			<title>
				Using our
				<classname>DataProvider</classname>
			</title>
			<para>
				We can now be pretty confident that our dataset works as expected
				with dozens
				of test cases behind it. Now we can go
				back to our
				<classname>Main</classname>
				class and start seeing how we access the data provided by this
				class.
			</para>
			<para>
				Data can be accessed from a provider in a number of ways,
				either
				paginated,
				non-paginated or using iterators
				(paginated or
				non-paginated). In our original
				example, we simply listed the first
				10 results. From the test code you
				might
				have seen a few more ways
				of accessing the data. First lets change our demo
				application to use
				an
				<classname>ObjectDataset</classname>
				instead of keeping separate
				<classname>Paginator</classname>
				and
				<classname>DataProvider</classname>
				references. The
				<classname>ObjectDataset</classname>
				combines these two interfaces and provides some benefits as we'll
				see.
			</para>
			<example>
				<title>
					Changing our demo application to use an
					<classname>ObjectDataset</classname>
				</title>
				<programlisting role="JAVA">
<![CDATA[
public static void main(String[] args) {
	ObjectDataset<Integer> ds = new Dataset<Integer>(new IntegerDataProvider());
	ds.setMaxRows(5);

	List<Integer> results = ds.getResultList();		
	showResults(results);			
}
]]>
</programlisting>
			</example>
			<para>If you run this now, it should run the same as before except
				for the
				fact that we changed the page size to 5 so
				we only return 5
				rows at a time for
				brevity. Let's add a second call to fetch the
				list of results and we'll see
				what
				happens.</para>
			<example>
				<title>
					Changing our demo application to use an
					<classname>ObjectDataset</classname>
				</title>
				<programlisting role="JAVA">
<![CDATA[
public static void main(String[] args) {
    DataProvider<Integer> provider = new IntegerDataProvider();
	ObjectDataset<Integer> ds = new Dataset<Integer>(provider);
	ds.setMaxRows(5);

	List<Integer> results = ds.getResultList();		
	showResults(results);
	showResults(ds.getResultList());			
}
]]>
</programlisting>
			</example>
			<figure>
				<title>Demo application results</title>
				<screen>			
Generating results from 1 to 5
Result Size = 5
Value = 1
Value = 2
Value = 3
Value = 4
Value = 5
Result Size = 5
Value = 1
Value = 2
Value = 3
Value = 4
Value = 5
</screen>
			</figure>
			<para>
				Unsurprisingly, we display the same list of numbers twice, but
				what
				is
				surprising is that we only generate the results
				the first
				time
				they are
				requested. The second time we call for the results,
				there is
				no message about
				generating
				results. This is because the
				<classname>ObjectDataset</classname>
				caches the results and only invalidates them when the pagination
				changes
				(i.e. the first result or page size is
				changed). You can
				manually force the
				results to be refreshed by calling
				<methodname>invalidateResults()</methodname>
				on the dataset. Doing so after the first call would force the
				dataset to
				re-fetch the data on the second call.
			</para>
			<para>
				This is one of the benefits of using a dataset on a thicker client
				or a
				stateful web app. The dataset can hold on to
				the results for
				you until you are
				done with them. Using separate
				<classname>Paginator</classname>
				and
				<classname>DataProvider</classname>
				instances can be useful in more stateless applications, or
				frameworks like
				Wicket that uses a detachable model that
				keeps hold
				of state, but lets you
				detach unwanted or re-fetchable state.
			</para>
			<sect2>
				<title>I want it all</title>
				<para>
					You can fetch all the results in the dataset by settings the
					<code>maxRows</code>
					to
					<code>null</code>
					. This means that when you call
					<code>getResults</code>
					you will get all the results from the
					<code>firstResult</code>
					index to the end. When you create a
					<classname>ObjectDataset</classname>
					by default, it is set up to fetch results from the first row and is
					not
					paginated so it will return all results from
					the beginning to
					the end.
				</para>
				<example>
					<title>Returning all results</title>
					<programlisting>
<![CDATA[
public static void main(String[] args) {
    DataProvider<Integer> provider = new IntegerDataProvider();
	ObjectDataset<Integer> ds = new Dataset<Integer>(provider);
	showResults(ds.getResultList());			
}
]]>
</programlisting>
				</example>
				<figure>
					<title>Returning all results</title>
					<screen>			
Generating results from 1 to 100
Result Size = 100
Value = 1
Value = 2
Value = 3
Value = 4
Value = 5
Value = 6
Value = 7
...
...
...
Value = 98
Value = 99
Value = 100
</screen>
				</figure>
			</sect2>
			<sect2>
				<title>Iteratively Speaking</title>
				<para>
					The dataset implements the
					<classname>Iterable</classname>
					interface which means that we can iterate over the dataset. If
					pagination is
					in use, it is performed transparently
					as you iterate
					through the dataset.
				</para>
				<example>
					<title>Returning all results</title>
					<programlisting>
<![CDATA[
public static void main(String[] args) {
    DataProvider<Integer> provider = new IntegerDataProvider();
	ObjectDataset<Integer> ds = new Dataset<Integer>(provider);
	ds.setMaxRows(5);
	for (Integer i : ds) {
		System.out.println("Iterating over value "+i);
	}		
}
]]>
</programlisting>
				</example>
				<figure>
					<title>Iterating over a paginated dataset</title>
					<screen>
Generating results from 1 to 5
Iterating over value 1
Iterating over value 2
Iterating over value 3
Iterating over value 4
Iterating over value 5
Generating results from 6 to 10
Iterating over value 6
Iterating over value 7
Iterating over value 8
Iterating over value 9
Iterating over value 10
Generating results from 11 to 15
Iterating over value 11
Iterating over value 12
...
...
...
terating over value 89
Iterating over value 90
Generating results from 91 to 95
Iterating over value 91
Iterating over value 92
Iterating over value 93
Iterating over value 94
Iterating over value 95
Generating results from 96 to 100
Iterating over value 96
Iterating over value 97
Iterating over value 98
Iterating over value 99
Iterating over value 100							
</screen>
				</figure>
				<para>This could be useful in cases where you want to group fetches
					into
					batches if fetches are expensive, or maybe
					even incorporate
					some
					multi-threading to let one thread fetch data and other threads
					to process
					result sets as they
					come in.</para>
			</sect2>
			<sect2>
				<title>Paging Datasets</title>
				<para>Generally paging through a dataset is done using the next and
					previous
					which changes the subset of data you are
					looking at.
					Generally speaking,
					using the iterator is the best way to iterate
					over every item in the dataset
					since
					paging is generally used to
					move to a specific page as to iterate
					through the data. </para>
				<para>Iterating manually is fraught with corner cases that could
					lead to a
					number of errors.</para>

				<example>
					<title>Attempting manual iteration</title>
					<programlisting>
<![CDATA[
//BROKEN CODE, DO NOT USE
while (ds.isNextAvailable()) {
	List<Integer> res = ds.getResultList();
	showResults(res);
	ds.next();
}
]]>
</programlisting>
				</example>
				<para>
					What happens here is that when we move to the last page using next,
					the
					<methodname>nextAvailable</methodname>
					property is set to false and we exit the loop before we display it.
					We could
					process the results after the loop but
					what happens when
					you forget to add
					the code at the end? The best demonstration of
					this is where the size of the
					result set is smaller than the page
					size, and when we fetch the first page
					of results,
					<methodname>nextAvailable</methodname>
					is false since this is the first and only page, and so we don't
					display the
					list.
				</para>
				<para>
					In general, use the dataset next/previous/first/last methods to
					navigate the
					dataset by moving from page to page and
					the
					<classname>Iterator</classname>
					implementation to go through the dataset item by item
					<superscript>*</superscript>
					. The iterator implementation handles all the corner cases in a
					familiar and
					consistent manner.
				</para>
				<para>
					Note that in the event of you reaching the end of the dataset
					and
					calling
					next, the active page will not change and
					you will
					receive
					the last result set
					back. Unless the dataset is empty,
					there will
					always be results returned in
					the
					result list, and if
					there are no
					results, an empty list should be
					returned. The results should never
					be
					<code>null</code>
					.
				</para>
				<note>
					<para>
						<superscript>*</superscript>
						We do use this kind of incorrect paging through data in
						some of the
						test
						cases, but only where we are not testing
						the
						number of
						results, but the
						actual result content, and we want to
						test the
						first/next/previous/last
						methods as
						opposed to the
						iterator
						implementation.
					</para>
				</note>
			</sect2>
			<sect2>
				<title>Manually Fetching Data</title>
				<para>
					As we discussed initially, the
					<classname>ObjectDataset</classname>
					is a helper construct that manages the two key interfaces of the
					<classname>Paginator</classname>
					and
					<classname>DataProvider</classname>
					. It is easy to use these two classes separately since there
					is no
					complex
					glue code implemented by the
					<classname>ObjectDataset</classname>
					except where it has provided enhanced features. Using two
					separately
					instantiated pagiantors and providers is straightforward :
				</para>

				<example>
					<title>Manually creating provider and pagination instances and
						fetching
						results</title>
					<programlisting>
<![CDATA[
DataProvider<Integer> provider = new IntegerDataProvider();
Paginator paginator = new SimplePaginator(10);
List<Integer> results = provider.fetchResults(paginator);
showResults(results); 			
]]>
</programlisting>
				</example>
				<para>
					Each call to
					<methodname>fetchResults</methodname>
					executes the process to fetch the data. This can mean running a
					database
					query or parsing a file. The results are
					not cached unlike
					the
					<classname>ObjectDataset</classname>
					. This is because the
					<classname>DataProvider</classname>
					and
					<classname>Paginator</classname>
					instances are the raw building blocks that make up the
					<classname>ObjectDataset</classname>
				</para>
				<para>
					One important thing to bear in mind with using these components
					manually is
					that the
					<classname>DataProvider</classname>
					implementation is responsible for setting the
					<code>nextAvailable</code>
					property on the
					<classname>Paginator</classname>
					instance passed in to the
					<methodname>fetchResults</methodname>
					method. This means that when you first create a paginator, the
					<methodname>isNextAvailable</methodname>
					value is false so you cannot create a new paginator instance and
					call the
					<methodname>next()</methodname>
					method since it, as well as other functions, depends on the
					<code>nextAvailable</code>
					flag.
				</para>
				<para>One benefit of using these standalone components manually is
					that you
					can use multiple paginator instances to
					provide different
					views of
					the same
					dataset independent of each other. This can be
					useful when you want
					application
					scoped data with local pagination.
				</para>
				<example>
					<title>Multiple views of the same data</title>
					<programlisting>
<![CDATA[
DataProvider<Integer> provider = new IntegerDataProvider();
Paginator paginator1 = new DefaultPaginator(10);
Paginator paginator2 = new DefaultPaginator(15);
paginator1.setFirstResult(20);
paginator2.setFirstResult(30);
		
System.out.println("First result = "+paginator1.getFirstResult());
		
List<Integer> results1 = provider.fetchResults(paginator1);
List<Integer> results2 = provider.fetchResults(paginator2);
System.out.println("Result Set 1");
showResults(results1); 			
System.out.println("Result Set 2");
showResults(results2);
]]>
</programlisting>
				</example>
				<para>Here we obtain two different sets of data from a single data
					provider.
					This can let you re-use data providers
					that obtain data
					from expensive data
					sources.</para>
			</sect2>

		</sect1>
	</chapter>

	<chapter>
		<title>The JQA Architecture</title>
		<para>
			Now we've
			covered these
			fundamentals of using JQA
			we can look at
			the different
			subclasses
			of the
			<classname>DataProvider</classname>
			interface and implementations so we create datasets that
			can
			attach to
			different datasources in a useful
			way.
		</para>
		<sect1>
			<title>Data Provider Types</title>
			<para>
				Most subclasses of the
				<classname>DataProvider</classname>
				are mirrored in some form of
				<classname>ObjectDataset</classname>
				subclass which acts as a thick client wrapper around the data
				provider and
				internally uses an instance of that
				particular subclass.
			</para>
			<sect2>
				<title>
					<classname>ParameterizedDataProvider</classname>
				</title>
				<para>
					The first subclass of the
					<classname>DataProvider</classname>
					interface is the
					<classname>ParameterizedDataProvider</classname>
					that introduces methods for fetching data based on dynamic
					parameters. This
					interface was conceived as a way to provide parameterization features on
					datasets that were non-sql based. For example, in a data provider that
					features file listings, you could have a directory parameter that indicates
					the directory to list files from.
				</para>
			</sect2>

			<sect2>
				<title>
					<classname>StatementDataProvider</classname>
				</title>
				<para>
					The
					<classname>StatementDataProvider</classname>
					extends the
					<classname>ParameterizedDataProvider</classname>
					and adds the ability to define string based statements for fetching
					and
					counting the number of rows of data. Since
					this extends the
					<classname>ParameterizedDataProvider</classname>
					we can let the user define statements that have parameters within
					them. This
					obviously lends itself to easily
					providing the bulk of
					features of a Sql or
					Ejbql or Hql data provider.
				</para>
			</sect2>
			<sect2>
				<title>
					<classname>AbstractQlDataProvider</classname>
				</title>
				<para>
					While this class isn't a part of the interface hierarchy, it is an
					important step on the concrete class implementations. It implements the
					generation of the query using a Sql like query language using the
					<classname>DataQueryBuilder</classname>
					which takes the statements and the restrictions, resolves the parameters
					and generates the final query. This query is then executed in the
					subclasses using the particular data access mechanism specific to that
					implementation.
					This class assumes only that there is a select and a count
					statement, and uses
					that to generate the query. The restrictions are
					introduced to the
					hierarchy and used in the query building later.
				</para>
			</sect2>
			<sect2>
				<title>
					<classname>QueryDataProvider</classname>
				</title>
				<para>
					The
					<classname>QueryDataProvider</classname>
					extends the
					<classname>StatementDataProvider</classname>
					and adds the ability to define restrictions and ordering. This class is
					really intended for targeting data stores that have a SQL-like query
					language which can be parameterized.
				</para>
			</sect2>
		</sect1>
		<sect1>
			<title>
				<classname>ObjectDataset</classname>
				Types
			</title>
			<para>
				<classname>ObjectDataset</classname>
				instances can help when using the data provider in a stateful manner. The
				dataset
				holds the current page of results (or the whole result set if there
				are no
				limits on the rows returned). The basic
				<classname>Dataset</classname>
				class takes a
				<classname>DataProvider</classname>
				implementation as its data provider. However, this can lead to code
				requiring a lot of casting if you don't use a basic
				<classname>DataProvider</classname>
				implementation.
			</para>
			<example>
				<title>Poorly typed provider and dataset useage</title>
				<programlisting>
<![CDATA[
		QueryDataProvider<Person> provider = new JpaQueryProvider<Person>();
		Dataset<Person> dataset = new Dataset<Person>(provider);
				
		// Won't work, getProvider returns a DataProvider, not a query data provider
		// DataProvider doesn't have the query data provider methods on there.
		//dataset.getProvider().addRestriction("p.id = :param",300);
		
		((JpaQueryProvider<Person>) dataset.getProvider()).addRestriction("p.id = :param",300);
]]>
</programlisting>
			</example>
			<para>
				Rather than force the user to keep type casting the provider, there is a
				generic implementation of the dataset that takes the type of data provider
				it uses as a parameter. This lets you call the
				<methodname>getProvider()</methodname>
				in a type safe manner.
			</para>
			<example>
				<title>Strongly types data provider and dataset usage</title>
				<programlisting>
<![CDATA[
		QueryDataProvider<Person> provider = new JpaQueryProvider<Person>();
		GenericProviderDataset<Person,QueryDataProvider<Person>> dataset = new GenericProviderDataset<Person,QueryDataProvider<Person>>(provider);
		dataset.getProvider().init(Person.class, "p");
		dataset.getProvider().addRestriction("p.id = #{personSearch.id}");
		dataset.getProvider().addParameterResolver(new MyParameterResolver());
]]>
</programlisting>
			</example>
			<para>
				This is further extended by creating implementations for the different
				type
				of query interfaces we use. In this example, rather than create a
				<classname>GenericProviderDataset</classname>
				with the provider class type as a generic parameter to the type, we can
				create a
				<classname>QueryDataset</classname>
				type that extends the
				<classname>GenericProviderDataset</classname>
				and sets the provider type parameter in its declaration to
				<classname>QueryDataProvider&lt;T&gt;</classname>
			</para>
			<example>
				<title>Type safety with the QueryDataProvider</title>
				<programlisting>
<![CDATA[
		QueryDataProvider<Person> provider = new JpaQueryProvider<Person>();
		QueryDataset<Person> dataset = new QueryDataset<Person>(provider);		
		dataset.getProvider().init(Person.class, "p");
		dataset.getProvider().addRestriction("p.id = #{person.id}");
]]>
</programlisting>
			</example>
			<para>
				We still maintain polymorphism because the
				<classname>QueryDataset</classname>
				implementation can take any data provider that implements the
				<classname>QueryDataProvider</classname>
				such as the JPA, Hibernate or SQL providers.
			</para>
			<para>
				In addition, these specialist dataset impementations also implement the
				appropriate data provider interfaces so you can save yourself the call to
				<methodname>getProvider()</methodname>
			</para>
			<example>
				<title>Type safety with the QueryDataProvider</title>
				<programlisting>
<![CDATA[
		QueryDataProvider<Person> provider = new JpaQueryProvider<Person>();
		QueryDataset<Person> dataset = new QueryDataset<Person>(provider);		
		dataset.init(Person.class, "p");
		dataset.addRestriction("p.id = #{person.id}");
		dataset.addParameterResolver(new MyParameterResolver());
]]>
</programlisting>
			</example>
		</sect1>
		<sect1>
			<title>Extending Dataset for custom providers</title>
			<para>
				When you create a new data provider implementation it is also good
				practice
				to implement a dataset wrapper for it so your users do not have to
				implement
				their own, or keep using the generic versions. Doing so is very simple, just
				create a new dataset class that extends the
				<classname>GenericProviderDataset</classname>
				and uses your own custom provider type as the type parameter.
			</para>
			<example>
				<title>Writing datasets for custom providers</title>
				<programlisting>
<![CDATA[
class MyCustomProvider<T> extends AbstractQueryDataProvider<T> {

        ...
        ...          
  		
  		//this is specific to this implementation
  		public void setWidgetConnection(WidgetConnection connection) {
  		  this.connection = conn
  		}
}

class MyCustomProviderDataset<T> extends GenericProviderDataset<T,MyCustomProvider<T>> {
   
   public MyCustomProviderDataset() {
     super();
   }
   
   public MyCustomProviderDataset(MyCustomProvider<T> provider) {
     super(provider);
   }
}
]]>
</programlisting>
			</example>
			<para>The dataset name should consist of the provider class name with the
				word dataset appended on the end to make it easy to remember. By including
				this class, it is easier to use datasets for custom data providers,
				especially for custom attributes on your new custom provider.</para>

			<example>
				<title>Using your new data provider dataset</title>
				<programlisting>
<![CDATA[
		MyCustomProvider<Person> provider = new MyCustomProvider<Person>();
		MyCustomProviderDataset<Person> ds = new MyCustomProviderDataset<Person>(provider);
		ds.getConnection().setWidgetConnection(ConnectionFactory.createConnection());
]]>
</programlisting>
			</example>

			<para>Note that while this provides accessibility to implementation specific
				functions, it does make your code more type specific and tightly bound. This
				has the effect of losing the ability to use polymorphism and making your
				code more tightly coupled to specific classes. </para>
			<para>To avoid this problem, only use more concrete class types in factory
				methods and return a more generalized provider or dataset type from the
				factory to the main application. This shouldn't be a problem since coding to
				concerete classes in the main application means your code won't be portable
				anyway if you start using specific methods in the custom provider or
				dataset.</para>

			<example>
				<title>Using your new data provider dataset</title>
				<programlisting>
<![CDATA[
   QueryProvider<Person> buildProvider() {
     MyCustomProvider<Person> result = new MyCustomProvider<Person>();
     result.setWidgetConnection(xyz);
     return result;     
   }
   
   QueryDataset<Person> buildDataset() {
     MyCustomProvider<Person> provider = buildProvider();
     MyCustomProviderDataset<Person> ds = new MyCustomProviderDataset<Person>();
     ds.getProvider().setWidgetConnection(ConnectionFactory.newConnection);
     return ds;
   }
   
   
   ...
   ...
   //assign the dataset using the generic dataset
   QueryProvider<Person> p = buildProvider();   
   QueryDataset<Person> ds = new QueryDataset<Person>(p);
   ds.getProvider().addRestriction("p.id = :param",id);
   
   
   //you can even assign custom datasets the the generic query dataset type
   QueryDataset<Person> ds2 = buildDataset(); 
]]>
</programlisting>
			</example>

		</sect1>
	</chapter>
	<chapter>
		<title>Non-Database Drive Providers</title>
		<para>There are a number of places you can choose to fetch data from and
			usually you are on your own regarding how you get that data into your
			application. JQA provides the ability to access non-databse data sources and
			fetch contents as pojos. It does by abstracting the concepts of fetching data
			to a level that is above retrieving it from the database. As a result, there
			are a number of different implementations for fetching data without a
			database while letting you benefit from using the same interfaces to fetch
			and control the data to be displayed.</para>
		<sect1>
			<title>In memory based datastores</title>
			<para>
				The simplest form of datastore is one which just keeps the objects in
				memory
				and are returned to the user when requested. An in memory data store
				subclasses the
				<classname>InMemoryDataProvider</classname>
				class and implements the abstract method to return the backing data. The
				backing data is the complete list of results that the data provider is
				paginating.
			</para>
			<example>
				<title>Simple implementation of our Integer date provider.</title>
				<programlisting>
<![CDATA[
   QueryProvider<Person> buildProvider() {
     MyCustomProvider<Person> result = new MyCustomProvider<Person>();
     result.setWidgetConnection(xyz);
     return result;     
   }
   
   QueryDataset<Person> buildDataset() {
     MyCustomProvider<Person> provider = buildProvider();
     MyCustomProviderDataset<Person> ds = new MyCustomProviderDataset<Person>();
     ds.getProvider().setWidgetConnection(ConnectionFactory.newConnection);
     return ds;
   }
   
   
   ...
   ...
   //assign the dataset using the generic dataset
   QueryProvider<Person> p = buildProvider();   
   QueryDataset<Person> ds = new QueryDataset<Person>(p);
   ds.getProvider().addRestriction("p.id = :param",id);
   
   
   //you can even assign custom datasets the the generic query dataset type
   QueryDataset<Person> ds2 = buildDataset(); 
]]>
</programlisting>
			</example>

			
		</sect1>
	</chapter>
</book>
	