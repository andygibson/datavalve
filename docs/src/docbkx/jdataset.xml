<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
 "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
	<title>JDataset Reference Guide</title>
	<titleabbrev>JDataset Ref</titleabbrev>
	<bookinfo>
		<author>
			<personname>
				<firstname>Andy</firstname>
				<surname>Gibson</surname>
			</personname>
		</author>
		<copyright>
			<year>2009</year>
			<holder>Andy Gibson</holder>
		</copyright>
	</bookinfo>
	<chapter id="Introduction">
		<title>Introduction</title>
		<sect1>
			<title>Introduction</title>
			<para>
				The purpose behind this framework is to let developers access
				diverse sources of data in an easy and consistent manner. It also
				aims to augment the functionalities of existing data access
				mechanisms such as JDBC, Hibernate and JPA.
</para>
			<para>By defining a set of common interfaces to access our data
				we can
				better provide reusable client components regardless of whether we
				are using various web frameworks or a Swing application as our
				client.
				We can also use those components to access data that does not
				have a
				typical access mechanism such as file listings, or uncommon
				data
				formats. Regardless, because we are coding to an interface, we
				are
				able to treat the data access the same way
				regardless of the
				complexity or unusual nature of the underlying
				data.
		</para>
		</sect1>
		<sect1>
			<title>Uses</title>
			<sect2>
				<title>Data Access Library Abstraction</title>
				<para>Typically, we consider using different mechanisms to access
					different types of data in our applications. For the most part this
					works just fine, we create pieces that are designed to work with
					that data access type. In some cases however, we need to access
					more diverse datasources that just a database. We might need to
					import or display something from a text file, or a set of data that
					is purely calculated. At that point, our visual interfaces to our
					data access type are no use because we are no longer using the same
					data access library, and we have to either duplicate the client
					code to deal with the new data access mechanism, or modify it to
					accept both data access types.
				</para>
				<figure>
					<title>Projects without using JDatasets</title>
					<mediaobject>
						<imageobject role="fo">
							<imagedata align="center" fileref="../img/app_without_jds.png"
								scalefit="1" />
						</imageobject>
						<imageobject role="html">
							<imagedata align="center" fileref="../img/app_without_jds.png" />
						</imageobject>
					</mediaobject>
				</figure>

				<para>JDataset sits between the client side, or the visual pieces of
					your application, and act as a facade to the various different type
					of data sources you might need. This way you only need to write one
					interface to fetch the data you need and you can keep re-using the
					same code, in multiple projects regardless of whether you are using
					JPA, hibernate or even text files as the datasource. You could for
					example create a JSF pagination facelet, or a Data provider class
					in Wicket that wraps a dataset. Both of these pieces of code can be
					re-used anywhere you use datasets.</para>
				<figure>
					<title>Projects using JDatasets</title>
					<mediaobject>
						<imageobject role="fo">
							<imagedata align="center" fileref="../img/app_with_jds.png"
								scalefit="1" />
						</imageobject>
						<imageobject role="html">
							<imagedata align="center" fileref="../img/app_with_jds.png" />
						</imageobject>
					</mediaobject>
				</figure>
				<para>
					Even if you use only one kind of data access, there are still
					advantages to using JDataset. By coding to the JDataset API, you
					can easily switch implementation later, from JPA to hibernate or
					plain JDBC queries. Also, if you later need to introduce some new
					kind of data access mechanism into the project, you can do so while
					using your existing code to interface with the data. Even if you
					can never imagine switching data access methods, or having to
					access diverse data stores, you may want to switch to a more
					efficient method of accessing data by using a straight SQL query
					instead of an ORM based query, but still want to interface with the
					data the same way you do with your ORM queries.</para>
			</sect2>
			<sect2>
				<title>Easier Dynamic Queries</title>

				<para>
					Also, JDatasets makes it easier to query for the data you
					need. It
					features flexible parameter specification, either set the
					value
					manually, use EL expressions, or extract the parameter values
					from
					an object using reflection. Parameters that don't have a value
					assigned can optionally be left out of the query. This can be
					really useful when you are writing search pages where you need to
					exclude the comparisons if there is no value to compare.
					</para>
				<example>
					<title>
						Coding search queries the hard way.
			</title>
					<programlisting role="XML">
<![CDATA[if (searchCriteria.id != null  && searchCriteria.id.length() != 0) {
    if (sql.length()!= null) {
      sql = sql + " AND ";
    }
    sql= sql+ "p.id = :id";
    paramsMap("id",searchCriteria.id);
}

if (searchCriteria.firstName != null  && searchCriteria.firstName.length() != 0) {
    if (sql.length()!= null) {
      sql = sql + " AND ";
    }
    sql= sql+ "p.firstName = :firstName";
    paramsMap("firstName",searchCriteria.firstName);
}

if (searchCriteria.lastName != null  && searchCriteria.lastName.length() != 0) {
    if (sql.length()!= null) {
      sql = sql + " AND ";
    }
    sql= sql+ "p.lastName = :lastName";
    paramsMap("lastName",searchCriteria.lastName);
}

qry = createQuery(sql);
for (String key : paramsMap.keySet) {
  qry.setParameter(key,paramsMap.get(key))
}

List<Person> results = qry.resultList();]]>
			</programlisting>

				</example>
				<para>Eh, kind of yucky. With JDataset, you can simply define the
					query once, specify how the parameters are resolved and the query
					will take care of generating the right query so that the only
					restrictions included in the query are ones with parameter values
					assigned.</para>
				<example>
					<title>
						Coding search queries the hard way.
			</title>
					<programlisting role="XML">
<![CDATA[qry.addRestriction("p.id = :id");
qry.addRestriction("p.firstName = :firstName");
qry.addRestriction("p.lastName = :lastName");
qry.addParameterResolver(new ReflectionParameterResolver(searchCriteria));
List<Person> results = qry.resultList();]]>
			</programlisting>
				</example>
				<para>26 Lines of code reduced to 5, and you get pagination thrown
					in
					for free and you can change datastores without needing to alter
					this
					code. </para>
			</sect2>
			<sect2>
				<title>Flexible and Secure Ordering Abstraction</title>
				<para>JDataset lets you order your dataset based on order keys as
					opposed to explicit SQL values which could be prone to SQL
					injection attacks. By using an orderKey value which is translated
					server side into a data level representation, you can control what
					values are used for ordering the dataset ensuring no harmful SQL is
					inserted into your query.</para>
			</sect2>
			<sect2>
				<title>Convert anything into a dataset</title>
				<para>JDataset provides a simple API which</para>
			</sect2>
		</sect1>
		<sect1>
			<title>Inspiration</title>
			<para>The inspiration for this project came from a few places. Being
				long time Borland Delphi developer, I used their data access
				omponents a lot and because they had a standard way of accessing
				ata, developers and third parties found it easy to create add-on
				omponents that would just work when connected to the data access
				omponents. However, because the data access components were so
				eature rich,
				hey could be hard to implement. This was partly
				ecause
				orland had not picked
				suitably simple base contract for the
				ataset and
				it
				as
				oo late to go back and
				reak the API after several
				ears of
				evelopment.</para>
			<para>
				Another source of inspiration is the
				<code>EntityQuery</code>
				framework in Seam. This query could use EL expressions to set query
				parameters and if the values were null, the parameters would be
				excluded. There were a few limitations with them and some things I
				would
				have done differently, so I wrote my own. However, every time I
				start looking at a new framework (Wicket, Spring MVC, ASP.net), I
				come
				across the same problems. Namely, querying data with or without
				excluding null parameters and handling pagination. I often found
				myself re-implementing this code or variants thereof and so this was
				my 'itch' that got me to develop this project, the need for one set
				of querying components that could provide those features and more.
			</para>
		</sect1>
	</chapter>

	<chapter id="Architecture">
		<title>Architecture Overview</title>
		<para>This chapter gives an overview of the general architecture of
			the datasets included in the library. There are different interfaces
			that are defined as part of JDatasets. Different query classes
			implement different interfaces to provide those features. </para>
		<sect1>
			<title>Key Interfaces</title>
			<para>This section lists the key interfaces in the framework. These
				interfaces are the ones that should be coded to when you create new
				JDataset implementation.
			</para>

			<sect2>
				<title>ObjectDataset</title>
				<para>
					The
					<code>org.jdataset.ObjectDataset</code>
					interface is the key interface to all the dataset classes. This
					interface defines functions for getting the result count, the
					result
					list and interacting with the pagination and
					navigation of the
					dataset.
				</para>
				<para>
					Most of this interface is implemented in the
					<code>org.jdataset.AbstractDataset</code>
					class. Most of the code relates to handling pagination and
					navigation but it also uses a strategy pattern to create two
					functions for fetching the result count and the actual list of
					results. The only other method which needs implementing is the
					<code>isNextAvailable()</code>
					method since there are a number of different ways this could be
					implemented.
				</para>
			</sect2>
			<sect2>
				<title>
					ParameterizedDataset
			</title>

				<para>
					The
					<code>ParameterizedDataset</code>
					interface extends the
					<code>ObjectDataset</code>
					interface and adds methods to provide parameters to our datasets.
					The
					<code>AbstractParameterizedQuery</code>
					implements these functions which similarly extends the
					<code>AbstractObjectDataset</code>
					. This interface adds methods to add parameter resolvers to the
					dataset and to resolve a parameter. It also lets you add parameter
					values to the dataset. For the most part, these parameters will end
					up in some kind of query language (QL - either Sql, Ejbql or Hql),
					but parameters may also be used in other places. For example, a
					directory listing dataset might have a file type parameter which
					you
					can set to limit the file types displayed.
				</para>
			</sect2>
			<sect2>
				<title>
					StatementDataset
			</title>
				<para>
					The
					<code>StatementDataset</code>
					interface extends the
					<code>ParameterizedDataset</code>
					interface and adds methods for getting and setting QL statements.
					This could be used to create a dataset that only has a select and
					count statement which would hold the whole QL statement that could
					hold parameters. However, for the most part, using a
					<code>QueryDataset</code>
					which automatically handles sorting and querying would be a better
					option.
				</para>
			</sect2>
			<sect2>
				<title>
					QueryDataset
			</title>
				<para>
					Query datasets extends the
					<code>StatementDataset</code>
					and add functions for having structured queries. This means we
					define the restrictions in the query, and provide the parameters
					needed. When we request the result set, the query is built as
					defined by the restrictions and the parameter values. Typically,
					these are likely to be subclassed for database oriented
					datasets as
					they are driven by a query language.
				</para>

				<para>
					Different data stores might have different needs from a
					dataset. For
					example, we can easily query and order a SQL, JPA, or Hibernate
					based dataset, but if we have a dataset that reads from a text
					file, we don't want to write a query engine to access the data from
					scratch, so
					for this reason, we provide different interfaces with
					different
					degrees of functionality all based around the core
					<code>ObjectDataset</code>
					interface.
				</para>
			</sect2>
		</sect1>
	</chapter>
	<chapter>
		<title>Getting Started</title>
		<para>
			Lets get started and start by creating our own custom dataset.
			JDataset can be installed into your local Maven repository or the jar
			files can be manually added to an IDE project. To start with create a
			new IDE and/or Maven project and add the
			<code>jdataset-core.jar</code>
			and the
			<code>jdataset-api.jar</code>
			or the
			<code>jdataset-core</code>
			dependency in Maven (all dependencies are in the
			<code>org.jdataset</code>
			group).
		</para>
		<sect1>
			<title>Simple Dataset</title>
			<para>
				Here we will extend the
				<code>AbstractObjectDataset</code>
				and implement the methods that will let us return a list of integers
				from 0 to 99.
			</para>

			<example>
				<title>
					Our first custom dataset
			</title>
				<programlisting role="JAVA">
<![CDATA[public class MyDataset extends AbstractDataset<Integer> {

	protected Integer fetchResultCount() {
		return 100;
	}

	protected List<Integer> fetchResults() {
		//determine the range of numbers to return
		int first=getFirstResult();
		//calculate the last result, getMaxRows==0 means return all rows
		int last = getMaxRows() == 0 ? first+getResultCount() :  first+getMaxRows();
		//check we are within bounds
		last = Math.min(last,getResultCount());
		
		//create the result list
		List<Integer> results = new ArrayList<Integer>();
		
		//generate the results
		for (int i = first;i < last;i++) {
			int value = first+i;
			//if we are ordering descending, invert the number
			if (!isOrderAscending()) {
				value = 99-value;
			}
			results.add(value);

		}
		return results; 
	}

	public boolean isNextAvailable() {
		//return whether there are more results left to fetch
		return getFirstResult() + getResultList().size() < getResultCount();
	}
}
]]>
			</programlisting>
			</example>
			<para>We can now create a little harness to execute that will create
				the dataset, show us some numbers and we can feel all proud.</para>

			<example>
				<title>
					Using our first dataset
			</title>
				<programlisting role="JAVA">
<![CDATA[public class Main {

	public static void main(String[] args) {

		ObjectDataset<Integer> ds = new MyDataset();
		ds.setMaxRows(5);
		System.out.println("Print page "+ds.getPage()+" of "+ds.getPageCount());
		for (Integer i : ds.getResultList()) {
			System.out.println(i);
		}
		ds.next();
		ds.next();
		System.out.println("Print page "+ds.getPage()+" of "+ds.getPageCount());
		for (Integer i : ds.getResultList()) {
			System.out.println(i);
		}
	}
}]]>
			</programlisting>
			</example>
			<para>If you run this, you will see the following output which means
				we have paginated the list of numbers and been able to navigate
				them. Note that from the implementation, you can see that the list
				is generated lazily and on demand. We could have written it so the
				dataset contained millions of rows and it would not have generated
				that list of a million numbers. It would only generate the list that
				was currently being requested in blocks of 5.</para>
			<example>
				<title>
					Using our first dataset
			</title>
				<programlisting role="JAVA">
<![CDATA[Print page 1 of 20
0
1
2
3
4
Print page 3 of 20
20
21
22
23
24]]>
</programlisting>
			</example>
		</sect1>
		<sect1>
			<title>Testing our first dataset</title>
			<para>
				The problem is, how do we know that our dataset meets all the
				contractual obligations of the
				<code>ObjectDataset</code>
				interface. How do we know we haven't missed some corner case where
				if the first result value is X and the page size is Y, it will
				return too many rows and error out. The answer is in automated unit
				testing and we are in luck, because we have a very well defined
				interface to test against. Because of this, we already have an
				abstract object dataset test class that you can subclass to test
				your own specific dataset with.
			</para>
			<para>
				Create a new class which subclasses the
				<code>AbstractObjectDatasetJUnitTest</code>
				. This class contains 30 tests (and growing) that can be used to
				check that your dataset is implemented correctly. You will need to
				add the junit jar or maven dependecy, as well as the
				<code>jdataset-test</code>
				jar/dependency.
			</para>
			<example>
				<title>
					Testing our first dataset
			</title>
				<programlisting role="JAVA">
<![CDATA[public class MyDatasetTest extends AbstractObjectDatasetJUnitTest<Integer> {

	@Override
	public ObjectDataset<Integer> buildObjectDataset() {
		return new MyDataset();		
	}

	@Override
	public int getDataRowCount() {
		return 100;
	}
}]]>
</programlisting>
			</example>
			<para>
				If you run these tests now, you should get the green light as the
				tests complete succesfully. The abstract test class implements a
				number of tests against the
				<code>ObjectDataset</code>
				interface. Chances are that you have implemented an interface such
				as a
				<code>ParameterizedDataset</code>
				or a
				<code>QueryDataset</code>
				and because they inherit from the
				<code>ObjectDataset</code>
				interface, they too can make use of the built in tester.
			</para>
		</sect1>
	</chapter>
</book>
		
